/* soapC.c
   Generated by gSOAP 2.8.18 from swad_web_service.h

Copyright(C) 2000-2014, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.18 2014-12-03 18:12:24 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_long:
		return soap_in_long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_swad__sendMessage:
		return soap_in_swad__sendMessage(soap, NULL, NULL, "swad:sendMessage");
	case SOAP_TYPE_swad__sendNotice:
		return soap_in_swad__sendNotice(soap, NULL, NULL, "swad:sendNotice");
	case SOAP_TYPE_swad__markNotificationsAsRead:
		return soap_in_swad__markNotificationsAsRead(soap, NULL, NULL, "swad:markNotificationsAsRead");
	case SOAP_TYPE_swad__getNotifications:
		return soap_in_swad__getNotifications(soap, NULL, NULL, "swad:getNotifications");
	case SOAP_TYPE_swad__sendAttendanceUsers:
		return soap_in_swad__sendAttendanceUsers(soap, NULL, NULL, "swad:sendAttendanceUsers");
	case SOAP_TYPE_swad__getAttendanceUsers:
		return soap_in_swad__getAttendanceUsers(soap, NULL, NULL, "swad:getAttendanceUsers");
	case SOAP_TYPE_swad__sendAttendanceEvent:
		return soap_in_swad__sendAttendanceEvent(soap, NULL, NULL, "swad:sendAttendanceEvent");
	case SOAP_TYPE_swad__getAttendanceEvents:
		return soap_in_swad__getAttendanceEvents(soap, NULL, NULL, "swad:getAttendanceEvents");
	case SOAP_TYPE_swad__getUsers:
		return soap_in_swad__getUsers(soap, NULL, NULL, "swad:getUsers");
	case SOAP_TYPE_swad__getTests:
		return soap_in_swad__getTests(soap, NULL, NULL, "swad:getTests");
	case SOAP_TYPE_swad__getTestConfig:
		return soap_in_swad__getTestConfig(soap, NULL, NULL, "swad:getTestConfig");
	case SOAP_TYPE_swad__getMarks:
		return soap_in_swad__getMarks(soap, NULL, NULL, "swad:getMarks");
	case SOAP_TYPE_swad__getFile:
		return soap_in_swad__getFile(soap, NULL, NULL, "swad:getFile");
	case SOAP_TYPE_swad__getDirectoryTree:
		return soap_in_swad__getDirectoryTree(soap, NULL, NULL, "swad:getDirectoryTree");
	case SOAP_TYPE_swad__sendMyGroups:
		return soap_in_swad__sendMyGroups(soap, NULL, NULL, "swad:sendMyGroups");
	case SOAP_TYPE_swad__getGroups:
		return soap_in_swad__getGroups(soap, NULL, NULL, "swad:getGroups");
	case SOAP_TYPE_swad__getGroupTypes:
		return soap_in_swad__getGroupTypes(soap, NULL, NULL, "swad:getGroupTypes");
	case SOAP_TYPE_swad__getCourseInfo:
		return soap_in_swad__getCourseInfo(soap, NULL, NULL, "swad:getCourseInfo");
	case SOAP_TYPE_swad__getCourses:
		return soap_in_swad__getCourses(soap, NULL, NULL, "swad:getCourses");
	case SOAP_TYPE_swad__getNewPassword:
		return soap_in_swad__getNewPassword(soap, NULL, NULL, "swad:getNewPassword");
	case SOAP_TYPE_swad__loginBySessionKey:
		return soap_in_swad__loginBySessionKey(soap, NULL, NULL, "swad:loginBySessionKey");
	case SOAP_TYPE_swad__loginByUserPasswordKey:
		return soap_in_swad__loginByUserPasswordKey(soap, NULL, NULL, "swad:loginByUserPasswordKey");
	case SOAP_TYPE_swad__createAccount:
		return soap_in_swad__createAccount(soap, NULL, NULL, "swad:createAccount");
	case SOAP_TYPE_swad__sendMessageOutput:
		return soap_in_swad__sendMessageOutput(soap, NULL, NULL, "swad:sendMessageOutput");
	case SOAP_TYPE_swad__sendNoticeOutput:
		return soap_in_swad__sendNoticeOutput(soap, NULL, NULL, "swad:sendNoticeOutput");
	case SOAP_TYPE_swad__getMarksOutput:
		return soap_in_swad__getMarksOutput(soap, NULL, NULL, "swad:getMarksOutput");
	case SOAP_TYPE_swad__getFileOutput:
		return soap_in_swad__getFileOutput(soap, NULL, NULL, "swad:getFileOutput");
	case SOAP_TYPE_swad__getDirectoryTreeOutput:
		return soap_in_swad__getDirectoryTreeOutput(soap, NULL, NULL, "swad:getDirectoryTreeOutput");
	case SOAP_TYPE_swad__sendAttendanceUsersOutput:
		return soap_in_swad__sendAttendanceUsersOutput(soap, NULL, NULL, "swad:sendAttendanceUsersOutput");
	case SOAP_TYPE_swad__getAttendanceUsersOutput:
		return soap_in_swad__getAttendanceUsersOutput(soap, NULL, NULL, "swad:getAttendanceUsersOutput");
	case SOAP_TYPE_swad__attendanceUsersArray:
		return soap_in_swad__attendanceUsersArray(soap, NULL, NULL, "swad:attendanceUsersArray");
	case SOAP_TYPE_swad__attendanceUser:
		return soap_in_swad__attendanceUser(soap, NULL, NULL, "swad:attendanceUser");
	case SOAP_TYPE_swad__sendAttendanceEventOutput:
		return soap_in_swad__sendAttendanceEventOutput(soap, NULL, NULL, "swad:sendAttendanceEventOutput");
	case SOAP_TYPE_swad__getAttendanceEventsOutput:
		return soap_in_swad__getAttendanceEventsOutput(soap, NULL, NULL, "swad:getAttendanceEventsOutput");
	case SOAP_TYPE_swad__attendanceEventsArray:
		return soap_in_swad__attendanceEventsArray(soap, NULL, NULL, "swad:attendanceEventsArray");
	case SOAP_TYPE_swad__attendanceEvent:
		return soap_in_swad__attendanceEvent(soap, NULL, NULL, "swad:attendanceEvent");
	case SOAP_TYPE_swad__getUsersOutput:
		return soap_in_swad__getUsersOutput(soap, NULL, NULL, "swad:getUsersOutput");
	case SOAP_TYPE_swad__usersArray:
		return soap_in_swad__usersArray(soap, NULL, NULL, "swad:usersArray");
	case SOAP_TYPE_swad__user:
		return soap_in_swad__user(soap, NULL, NULL, "swad:user");
	case SOAP_TYPE_swad__getTestsOutput:
		return soap_in_swad__getTestsOutput(soap, NULL, NULL, "swad:getTestsOutput");
	case SOAP_TYPE_swad__questionTagsArray:
		return soap_in_swad__questionTagsArray(soap, NULL, NULL, "swad:questionTagsArray");
	case SOAP_TYPE_swad__questionTag:
		return soap_in_swad__questionTag(soap, NULL, NULL, "swad:questionTag");
	case SOAP_TYPE_swad__answersArray:
		return soap_in_swad__answersArray(soap, NULL, NULL, "swad:answersArray");
	case SOAP_TYPE_swad__answer:
		return soap_in_swad__answer(soap, NULL, NULL, "swad:answer");
	case SOAP_TYPE_swad__questionsArray:
		return soap_in_swad__questionsArray(soap, NULL, NULL, "swad:questionsArray");
	case SOAP_TYPE_swad__question:
		return soap_in_swad__question(soap, NULL, NULL, "swad:question");
	case SOAP_TYPE_swad__tagsArray:
		return soap_in_swad__tagsArray(soap, NULL, NULL, "swad:tagsArray");
	case SOAP_TYPE_swad__tag:
		return soap_in_swad__tag(soap, NULL, NULL, "swad:tag");
	case SOAP_TYPE_swad__getTestConfigOutput:
		return soap_in_swad__getTestConfigOutput(soap, NULL, NULL, "swad:getTestConfigOutput");
	case SOAP_TYPE_swad__markNotificationsAsReadOutput:
		return soap_in_swad__markNotificationsAsReadOutput(soap, NULL, NULL, "swad:markNotificationsAsReadOutput");
	case SOAP_TYPE_swad__getNotificationsOutput:
		return soap_in_swad__getNotificationsOutput(soap, NULL, NULL, "swad:getNotificationsOutput");
	case SOAP_TYPE_swad__notificationsArray:
		return soap_in_swad__notificationsArray(soap, NULL, NULL, "swad:notificationsArray");
	case SOAP_TYPE_swad__notification:
		return soap_in_swad__notification(soap, NULL, NULL, "swad:notification");
	case SOAP_TYPE_swad__sendMyGroupsOutput:
		return soap_in_swad__sendMyGroupsOutput(soap, NULL, NULL, "swad:sendMyGroupsOutput");
	case SOAP_TYPE_swad__getGroupsOutput:
		return soap_in_swad__getGroupsOutput(soap, NULL, NULL, "swad:getGroupsOutput");
	case SOAP_TYPE_swad__groupsArray:
		return soap_in_swad__groupsArray(soap, NULL, NULL, "swad:groupsArray");
	case SOAP_TYPE_swad__group:
		return soap_in_swad__group(soap, NULL, NULL, "swad:group");
	case SOAP_TYPE_swad__getGroupTypesOutput:
		return soap_in_swad__getGroupTypesOutput(soap, NULL, NULL, "swad:getGroupTypesOutput");
	case SOAP_TYPE_swad__groupTypesArray:
		return soap_in_swad__groupTypesArray(soap, NULL, NULL, "swad:groupTypesArray");
	case SOAP_TYPE_swad__groupType:
		return soap_in_swad__groupType(soap, NULL, NULL, "swad:groupType");
	case SOAP_TYPE_swad__getCourseInfoOutput:
		return soap_in_swad__getCourseInfoOutput(soap, NULL, NULL, "swad:getCourseInfoOutput");
	case SOAP_TYPE_swad__getCoursesOutput:
		return soap_in_swad__getCoursesOutput(soap, NULL, NULL, "swad:getCoursesOutput");
	case SOAP_TYPE_swad__coursesArray:
		return soap_in_swad__coursesArray(soap, NULL, NULL, "swad:coursesArray");
	case SOAP_TYPE_swad__course:
		return soap_in_swad__course(soap, NULL, NULL, "swad:course");
	case SOAP_TYPE_swad__getNewPasswordOutput:
		return soap_in_swad__getNewPasswordOutput(soap, NULL, NULL, "swad:getNewPasswordOutput");
	case SOAP_TYPE_swad__loginByUserPasswordKeyOutput:
		return soap_in_swad__loginByUserPasswordKeyOutput(soap, NULL, NULL, "swad:loginByUserPasswordKeyOutput");
	case SOAP_TYPE_swad__loginBySessionKeyOutput:
		return soap_in_swad__loginBySessionKeyOutput(soap, NULL, NULL, "swad:loginBySessionKeyOutput");
	case SOAP_TYPE_swad__createAccountOutput:
		return soap_in_swad__createAccountOutput(soap, NULL, NULL, "swad:createAccountOutput");
	case SOAP_TYPE_PointerToswad__sendMessageOutput:
		return soap_in_PointerToswad__sendMessageOutput(soap, NULL, NULL, "swad:sendMessageOutput");
	case SOAP_TYPE_PointerToswad__sendNoticeOutput:
		return soap_in_PointerToswad__sendNoticeOutput(soap, NULL, NULL, "swad:sendNoticeOutput");
	case SOAP_TYPE_PointerToswad__markNotificationsAsReadOutput:
		return soap_in_PointerToswad__markNotificationsAsReadOutput(soap, NULL, NULL, "swad:markNotificationsAsReadOutput");
	case SOAP_TYPE_PointerToswad__getNotificationsOutput:
		return soap_in_PointerToswad__getNotificationsOutput(soap, NULL, NULL, "swad:getNotificationsOutput");
	case SOAP_TYPE_PointerToswad__sendAttendanceUsersOutput:
		return soap_in_PointerToswad__sendAttendanceUsersOutput(soap, NULL, NULL, "swad:sendAttendanceUsersOutput");
	case SOAP_TYPE_PointerToswad__getAttendanceUsersOutput:
		return soap_in_PointerToswad__getAttendanceUsersOutput(soap, NULL, NULL, "swad:getAttendanceUsersOutput");
	case SOAP_TYPE_PointerToswad__sendAttendanceEventOutput:
		return soap_in_PointerToswad__sendAttendanceEventOutput(soap, NULL, NULL, "swad:sendAttendanceEventOutput");
	case SOAP_TYPE_PointerToswad__getAttendanceEventsOutput:
		return soap_in_PointerToswad__getAttendanceEventsOutput(soap, NULL, NULL, "swad:getAttendanceEventsOutput");
	case SOAP_TYPE_PointerToswad__getUsersOutput:
		return soap_in_PointerToswad__getUsersOutput(soap, NULL, NULL, "swad:getUsersOutput");
	case SOAP_TYPE_PointerToswad__getTestsOutput:
		return soap_in_PointerToswad__getTestsOutput(soap, NULL, NULL, "swad:getTestsOutput");
	case SOAP_TYPE_PointerToswad__getTestConfigOutput:
		return soap_in_PointerToswad__getTestConfigOutput(soap, NULL, NULL, "swad:getTestConfigOutput");
	case SOAP_TYPE_PointerToswad__getMarksOutput:
		return soap_in_PointerToswad__getMarksOutput(soap, NULL, NULL, "swad:getMarksOutput");
	case SOAP_TYPE_PointerToswad__getFileOutput:
		return soap_in_PointerToswad__getFileOutput(soap, NULL, NULL, "swad:getFileOutput");
	case SOAP_TYPE_PointerToswad__getDirectoryTreeOutput:
		return soap_in_PointerToswad__getDirectoryTreeOutput(soap, NULL, NULL, "swad:getDirectoryTreeOutput");
	case SOAP_TYPE_PointerToswad__sendMyGroupsOutput:
		return soap_in_PointerToswad__sendMyGroupsOutput(soap, NULL, NULL, "swad:sendMyGroupsOutput");
	case SOAP_TYPE_PointerToswad__getGroupsOutput:
		return soap_in_PointerToswad__getGroupsOutput(soap, NULL, NULL, "swad:getGroupsOutput");
	case SOAP_TYPE_PointerToswad__getGroupTypesOutput:
		return soap_in_PointerToswad__getGroupTypesOutput(soap, NULL, NULL, "swad:getGroupTypesOutput");
	case SOAP_TYPE_PointerToswad__getCourseInfoOutput:
		return soap_in_PointerToswad__getCourseInfoOutput(soap, NULL, NULL, "swad:getCourseInfoOutput");
	case SOAP_TYPE_PointerToswad__getCoursesOutput:
		return soap_in_PointerToswad__getCoursesOutput(soap, NULL, NULL, "swad:getCoursesOutput");
	case SOAP_TYPE_PointerToswad__getNewPasswordOutput:
		return soap_in_PointerToswad__getNewPasswordOutput(soap, NULL, NULL, "swad:getNewPasswordOutput");
	case SOAP_TYPE_PointerToswad__loginBySessionKeyOutput:
		return soap_in_PointerToswad__loginBySessionKeyOutput(soap, NULL, NULL, "swad:loginBySessionKeyOutput");
	case SOAP_TYPE_PointerToswad__loginByUserPasswordKeyOutput:
		return soap_in_PointerToswad__loginByUserPasswordKeyOutput(soap, NULL, NULL, "swad:loginByUserPasswordKeyOutput");
	case SOAP_TYPE_PointerToswad__createAccountOutput:
		return soap_in_PointerToswad__createAccountOutput(soap, NULL, NULL, "swad:createAccountOutput");
	case SOAP_TYPE_PointerToswad__attendanceUser:
		return soap_in_PointerToswad__attendanceUser(soap, NULL, NULL, "swad:attendanceUser");
	case SOAP_TYPE_PointerToswad__attendanceEvent:
		return soap_in_PointerToswad__attendanceEvent(soap, NULL, NULL, "swad:attendanceEvent");
	case SOAP_TYPE_PointerToswad__user:
		return soap_in_PointerToswad__user(soap, NULL, NULL, "swad:user");
	case SOAP_TYPE_PointerToswad__questionTag:
		return soap_in_PointerToswad__questionTag(soap, NULL, NULL, "swad:questionTag");
	case SOAP_TYPE_PointerToswad__answer:
		return soap_in_PointerToswad__answer(soap, NULL, NULL, "swad:answer");
	case SOAP_TYPE_PointerToswad__question:
		return soap_in_PointerToswad__question(soap, NULL, NULL, "swad:question");
	case SOAP_TYPE_PointerToswad__tag:
		return soap_in_PointerToswad__tag(soap, NULL, NULL, "swad:tag");
	case SOAP_TYPE_PointerToswad__notification:
		return soap_in_PointerToswad__notification(soap, NULL, NULL, "swad:notification");
	case SOAP_TYPE_PointerToswad__group:
		return soap_in_PointerToswad__group(soap, NULL, NULL, "swad:group");
	case SOAP_TYPE_PointerToswad__groupType:
		return soap_in_PointerToswad__groupType(soap, NULL, NULL, "swad:groupType");
	case SOAP_TYPE_PointerToswad__course:
		return soap_in_PointerToswad__course(soap, NULL, NULL, "swad:course");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_long;
			return soap_in_long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:sendMessage"))
		{	*type = SOAP_TYPE_swad__sendMessage;
			return soap_in_swad__sendMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:sendNotice"))
		{	*type = SOAP_TYPE_swad__sendNotice;
			return soap_in_swad__sendNotice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:markNotificationsAsRead"))
		{	*type = SOAP_TYPE_swad__markNotificationsAsRead;
			return soap_in_swad__markNotificationsAsRead(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getNotifications"))
		{	*type = SOAP_TYPE_swad__getNotifications;
			return soap_in_swad__getNotifications(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:sendAttendanceUsers"))
		{	*type = SOAP_TYPE_swad__sendAttendanceUsers;
			return soap_in_swad__sendAttendanceUsers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getAttendanceUsers"))
		{	*type = SOAP_TYPE_swad__getAttendanceUsers;
			return soap_in_swad__getAttendanceUsers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:sendAttendanceEvent"))
		{	*type = SOAP_TYPE_swad__sendAttendanceEvent;
			return soap_in_swad__sendAttendanceEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getAttendanceEvents"))
		{	*type = SOAP_TYPE_swad__getAttendanceEvents;
			return soap_in_swad__getAttendanceEvents(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getUsers"))
		{	*type = SOAP_TYPE_swad__getUsers;
			return soap_in_swad__getUsers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getTests"))
		{	*type = SOAP_TYPE_swad__getTests;
			return soap_in_swad__getTests(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getTestConfig"))
		{	*type = SOAP_TYPE_swad__getTestConfig;
			return soap_in_swad__getTestConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getMarks"))
		{	*type = SOAP_TYPE_swad__getMarks;
			return soap_in_swad__getMarks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getFile"))
		{	*type = SOAP_TYPE_swad__getFile;
			return soap_in_swad__getFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getDirectoryTree"))
		{	*type = SOAP_TYPE_swad__getDirectoryTree;
			return soap_in_swad__getDirectoryTree(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:sendMyGroups"))
		{	*type = SOAP_TYPE_swad__sendMyGroups;
			return soap_in_swad__sendMyGroups(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getGroups"))
		{	*type = SOAP_TYPE_swad__getGroups;
			return soap_in_swad__getGroups(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getGroupTypes"))
		{	*type = SOAP_TYPE_swad__getGroupTypes;
			return soap_in_swad__getGroupTypes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getCourseInfo"))
		{	*type = SOAP_TYPE_swad__getCourseInfo;
			return soap_in_swad__getCourseInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getCourses"))
		{	*type = SOAP_TYPE_swad__getCourses;
			return soap_in_swad__getCourses(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getNewPassword"))
		{	*type = SOAP_TYPE_swad__getNewPassword;
			return soap_in_swad__getNewPassword(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:loginBySessionKey"))
		{	*type = SOAP_TYPE_swad__loginBySessionKey;
			return soap_in_swad__loginBySessionKey(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:loginByUserPasswordKey"))
		{	*type = SOAP_TYPE_swad__loginByUserPasswordKey;
			return soap_in_swad__loginByUserPasswordKey(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:createAccount"))
		{	*type = SOAP_TYPE_swad__createAccount;
			return soap_in_swad__createAccount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:sendMessageOutput"))
		{	*type = SOAP_TYPE_swad__sendMessageOutput;
			return soap_in_swad__sendMessageOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:sendNoticeOutput"))
		{	*type = SOAP_TYPE_swad__sendNoticeOutput;
			return soap_in_swad__sendNoticeOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getMarksOutput"))
		{	*type = SOAP_TYPE_swad__getMarksOutput;
			return soap_in_swad__getMarksOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getFileOutput"))
		{	*type = SOAP_TYPE_swad__getFileOutput;
			return soap_in_swad__getFileOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getDirectoryTreeOutput"))
		{	*type = SOAP_TYPE_swad__getDirectoryTreeOutput;
			return soap_in_swad__getDirectoryTreeOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:sendAttendanceUsersOutput"))
		{	*type = SOAP_TYPE_swad__sendAttendanceUsersOutput;
			return soap_in_swad__sendAttendanceUsersOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getAttendanceUsersOutput"))
		{	*type = SOAP_TYPE_swad__getAttendanceUsersOutput;
			return soap_in_swad__getAttendanceUsersOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:attendanceUsersArray"))
		{	*type = SOAP_TYPE_swad__attendanceUsersArray;
			return soap_in_swad__attendanceUsersArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:attendanceUser"))
		{	*type = SOAP_TYPE_swad__attendanceUser;
			return soap_in_swad__attendanceUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:sendAttendanceEventOutput"))
		{	*type = SOAP_TYPE_swad__sendAttendanceEventOutput;
			return soap_in_swad__sendAttendanceEventOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getAttendanceEventsOutput"))
		{	*type = SOAP_TYPE_swad__getAttendanceEventsOutput;
			return soap_in_swad__getAttendanceEventsOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:attendanceEventsArray"))
		{	*type = SOAP_TYPE_swad__attendanceEventsArray;
			return soap_in_swad__attendanceEventsArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:attendanceEvent"))
		{	*type = SOAP_TYPE_swad__attendanceEvent;
			return soap_in_swad__attendanceEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getUsersOutput"))
		{	*type = SOAP_TYPE_swad__getUsersOutput;
			return soap_in_swad__getUsersOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:usersArray"))
		{	*type = SOAP_TYPE_swad__usersArray;
			return soap_in_swad__usersArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:user"))
		{	*type = SOAP_TYPE_swad__user;
			return soap_in_swad__user(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getTestsOutput"))
		{	*type = SOAP_TYPE_swad__getTestsOutput;
			return soap_in_swad__getTestsOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:questionTagsArray"))
		{	*type = SOAP_TYPE_swad__questionTagsArray;
			return soap_in_swad__questionTagsArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:questionTag"))
		{	*type = SOAP_TYPE_swad__questionTag;
			return soap_in_swad__questionTag(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:answersArray"))
		{	*type = SOAP_TYPE_swad__answersArray;
			return soap_in_swad__answersArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:answer"))
		{	*type = SOAP_TYPE_swad__answer;
			return soap_in_swad__answer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:questionsArray"))
		{	*type = SOAP_TYPE_swad__questionsArray;
			return soap_in_swad__questionsArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:question"))
		{	*type = SOAP_TYPE_swad__question;
			return soap_in_swad__question(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:tagsArray"))
		{	*type = SOAP_TYPE_swad__tagsArray;
			return soap_in_swad__tagsArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:tag"))
		{	*type = SOAP_TYPE_swad__tag;
			return soap_in_swad__tag(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getTestConfigOutput"))
		{	*type = SOAP_TYPE_swad__getTestConfigOutput;
			return soap_in_swad__getTestConfigOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:markNotificationsAsReadOutput"))
		{	*type = SOAP_TYPE_swad__markNotificationsAsReadOutput;
			return soap_in_swad__markNotificationsAsReadOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getNotificationsOutput"))
		{	*type = SOAP_TYPE_swad__getNotificationsOutput;
			return soap_in_swad__getNotificationsOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:notificationsArray"))
		{	*type = SOAP_TYPE_swad__notificationsArray;
			return soap_in_swad__notificationsArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:notification"))
		{	*type = SOAP_TYPE_swad__notification;
			return soap_in_swad__notification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:sendMyGroupsOutput"))
		{	*type = SOAP_TYPE_swad__sendMyGroupsOutput;
			return soap_in_swad__sendMyGroupsOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getGroupsOutput"))
		{	*type = SOAP_TYPE_swad__getGroupsOutput;
			return soap_in_swad__getGroupsOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:groupsArray"))
		{	*type = SOAP_TYPE_swad__groupsArray;
			return soap_in_swad__groupsArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:group"))
		{	*type = SOAP_TYPE_swad__group;
			return soap_in_swad__group(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getGroupTypesOutput"))
		{	*type = SOAP_TYPE_swad__getGroupTypesOutput;
			return soap_in_swad__getGroupTypesOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:groupTypesArray"))
		{	*type = SOAP_TYPE_swad__groupTypesArray;
			return soap_in_swad__groupTypesArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:groupType"))
		{	*type = SOAP_TYPE_swad__groupType;
			return soap_in_swad__groupType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getCourseInfoOutput"))
		{	*type = SOAP_TYPE_swad__getCourseInfoOutput;
			return soap_in_swad__getCourseInfoOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getCoursesOutput"))
		{	*type = SOAP_TYPE_swad__getCoursesOutput;
			return soap_in_swad__getCoursesOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:coursesArray"))
		{	*type = SOAP_TYPE_swad__coursesArray;
			return soap_in_swad__coursesArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:course"))
		{	*type = SOAP_TYPE_swad__course;
			return soap_in_swad__course(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:getNewPasswordOutput"))
		{	*type = SOAP_TYPE_swad__getNewPasswordOutput;
			return soap_in_swad__getNewPasswordOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:loginByUserPasswordKeyOutput"))
		{	*type = SOAP_TYPE_swad__loginByUserPasswordKeyOutput;
			return soap_in_swad__loginByUserPasswordKeyOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:loginBySessionKeyOutput"))
		{	*type = SOAP_TYPE_swad__loginBySessionKeyOutput;
			return soap_in_swad__loginBySessionKeyOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "swad:createAccountOutput"))
		{	*type = SOAP_TYPE_swad__createAccountOutput;
			return soap_in_swad__createAccountOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_long:
		return soap_out_long(soap, tag, id, (const long *)ptr, "xsd:long");
	case SOAP_TYPE_swad__sendMessage:
		return soap_out_swad__sendMessage(soap, tag, id, (const struct swad__sendMessage *)ptr, "swad:sendMessage");
	case SOAP_TYPE_swad__sendNotice:
		return soap_out_swad__sendNotice(soap, tag, id, (const struct swad__sendNotice *)ptr, "swad:sendNotice");
	case SOAP_TYPE_swad__markNotificationsAsRead:
		return soap_out_swad__markNotificationsAsRead(soap, tag, id, (const struct swad__markNotificationsAsRead *)ptr, "swad:markNotificationsAsRead");
	case SOAP_TYPE_swad__getNotifications:
		return soap_out_swad__getNotifications(soap, tag, id, (const struct swad__getNotifications *)ptr, "swad:getNotifications");
	case SOAP_TYPE_swad__sendAttendanceUsers:
		return soap_out_swad__sendAttendanceUsers(soap, tag, id, (const struct swad__sendAttendanceUsers *)ptr, "swad:sendAttendanceUsers");
	case SOAP_TYPE_swad__getAttendanceUsers:
		return soap_out_swad__getAttendanceUsers(soap, tag, id, (const struct swad__getAttendanceUsers *)ptr, "swad:getAttendanceUsers");
	case SOAP_TYPE_swad__sendAttendanceEvent:
		return soap_out_swad__sendAttendanceEvent(soap, tag, id, (const struct swad__sendAttendanceEvent *)ptr, "swad:sendAttendanceEvent");
	case SOAP_TYPE_swad__getAttendanceEvents:
		return soap_out_swad__getAttendanceEvents(soap, tag, id, (const struct swad__getAttendanceEvents *)ptr, "swad:getAttendanceEvents");
	case SOAP_TYPE_swad__getUsers:
		return soap_out_swad__getUsers(soap, tag, id, (const struct swad__getUsers *)ptr, "swad:getUsers");
	case SOAP_TYPE_swad__getTests:
		return soap_out_swad__getTests(soap, tag, id, (const struct swad__getTests *)ptr, "swad:getTests");
	case SOAP_TYPE_swad__getTestConfig:
		return soap_out_swad__getTestConfig(soap, tag, id, (const struct swad__getTestConfig *)ptr, "swad:getTestConfig");
	case SOAP_TYPE_swad__getMarks:
		return soap_out_swad__getMarks(soap, tag, id, (const struct swad__getMarks *)ptr, "swad:getMarks");
	case SOAP_TYPE_swad__getFile:
		return soap_out_swad__getFile(soap, tag, id, (const struct swad__getFile *)ptr, "swad:getFile");
	case SOAP_TYPE_swad__getDirectoryTree:
		return soap_out_swad__getDirectoryTree(soap, tag, id, (const struct swad__getDirectoryTree *)ptr, "swad:getDirectoryTree");
	case SOAP_TYPE_swad__sendMyGroups:
		return soap_out_swad__sendMyGroups(soap, tag, id, (const struct swad__sendMyGroups *)ptr, "swad:sendMyGroups");
	case SOAP_TYPE_swad__getGroups:
		return soap_out_swad__getGroups(soap, tag, id, (const struct swad__getGroups *)ptr, "swad:getGroups");
	case SOAP_TYPE_swad__getGroupTypes:
		return soap_out_swad__getGroupTypes(soap, tag, id, (const struct swad__getGroupTypes *)ptr, "swad:getGroupTypes");
	case SOAP_TYPE_swad__getCourseInfo:
		return soap_out_swad__getCourseInfo(soap, tag, id, (const struct swad__getCourseInfo *)ptr, "swad:getCourseInfo");
	case SOAP_TYPE_swad__getCourses:
		return soap_out_swad__getCourses(soap, tag, id, (const struct swad__getCourses *)ptr, "swad:getCourses");
	case SOAP_TYPE_swad__getNewPassword:
		return soap_out_swad__getNewPassword(soap, tag, id, (const struct swad__getNewPassword *)ptr, "swad:getNewPassword");
	case SOAP_TYPE_swad__loginBySessionKey:
		return soap_out_swad__loginBySessionKey(soap, tag, id, (const struct swad__loginBySessionKey *)ptr, "swad:loginBySessionKey");
	case SOAP_TYPE_swad__loginByUserPasswordKey:
		return soap_out_swad__loginByUserPasswordKey(soap, tag, id, (const struct swad__loginByUserPasswordKey *)ptr, "swad:loginByUserPasswordKey");
	case SOAP_TYPE_swad__createAccount:
		return soap_out_swad__createAccount(soap, tag, id, (const struct swad__createAccount *)ptr, "swad:createAccount");
	case SOAP_TYPE_swad__sendMessageOutput:
		return soap_out_swad__sendMessageOutput(soap, tag, id, (const struct swad__sendMessageOutput *)ptr, "swad:sendMessageOutput");
	case SOAP_TYPE_swad__sendNoticeOutput:
		return soap_out_swad__sendNoticeOutput(soap, tag, id, (const struct swad__sendNoticeOutput *)ptr, "swad:sendNoticeOutput");
	case SOAP_TYPE_swad__getMarksOutput:
		return soap_out_swad__getMarksOutput(soap, tag, id, (const struct swad__getMarksOutput *)ptr, "swad:getMarksOutput");
	case SOAP_TYPE_swad__getFileOutput:
		return soap_out_swad__getFileOutput(soap, tag, id, (const struct swad__getFileOutput *)ptr, "swad:getFileOutput");
	case SOAP_TYPE_swad__getDirectoryTreeOutput:
		return soap_out_swad__getDirectoryTreeOutput(soap, tag, id, (const struct swad__getDirectoryTreeOutput *)ptr, "swad:getDirectoryTreeOutput");
	case SOAP_TYPE_swad__sendAttendanceUsersOutput:
		return soap_out_swad__sendAttendanceUsersOutput(soap, tag, id, (const struct swad__sendAttendanceUsersOutput *)ptr, "swad:sendAttendanceUsersOutput");
	case SOAP_TYPE_swad__getAttendanceUsersOutput:
		return soap_out_swad__getAttendanceUsersOutput(soap, tag, id, (const struct swad__getAttendanceUsersOutput *)ptr, "swad:getAttendanceUsersOutput");
	case SOAP_TYPE_swad__attendanceUsersArray:
		return soap_out_swad__attendanceUsersArray(soap, tag, id, (const struct swad__attendanceUsersArray *)ptr, "swad:attendanceUsersArray");
	case SOAP_TYPE_swad__attendanceUser:
		return soap_out_swad__attendanceUser(soap, tag, id, (const struct swad__attendanceUser *)ptr, "swad:attendanceUser");
	case SOAP_TYPE_swad__sendAttendanceEventOutput:
		return soap_out_swad__sendAttendanceEventOutput(soap, tag, id, (const struct swad__sendAttendanceEventOutput *)ptr, "swad:sendAttendanceEventOutput");
	case SOAP_TYPE_swad__getAttendanceEventsOutput:
		return soap_out_swad__getAttendanceEventsOutput(soap, tag, id, (const struct swad__getAttendanceEventsOutput *)ptr, "swad:getAttendanceEventsOutput");
	case SOAP_TYPE_swad__attendanceEventsArray:
		return soap_out_swad__attendanceEventsArray(soap, tag, id, (const struct swad__attendanceEventsArray *)ptr, "swad:attendanceEventsArray");
	case SOAP_TYPE_swad__attendanceEvent:
		return soap_out_swad__attendanceEvent(soap, tag, id, (const struct swad__attendanceEvent *)ptr, "swad:attendanceEvent");
	case SOAP_TYPE_swad__getUsersOutput:
		return soap_out_swad__getUsersOutput(soap, tag, id, (const struct swad__getUsersOutput *)ptr, "swad:getUsersOutput");
	case SOAP_TYPE_swad__usersArray:
		return soap_out_swad__usersArray(soap, tag, id, (const struct swad__usersArray *)ptr, "swad:usersArray");
	case SOAP_TYPE_swad__user:
		return soap_out_swad__user(soap, tag, id, (const struct swad__user *)ptr, "swad:user");
	case SOAP_TYPE_swad__getTestsOutput:
		return soap_out_swad__getTestsOutput(soap, tag, id, (const struct swad__getTestsOutput *)ptr, "swad:getTestsOutput");
	case SOAP_TYPE_swad__questionTagsArray:
		return soap_out_swad__questionTagsArray(soap, tag, id, (const struct swad__questionTagsArray *)ptr, "swad:questionTagsArray");
	case SOAP_TYPE_swad__questionTag:
		return soap_out_swad__questionTag(soap, tag, id, (const struct swad__questionTag *)ptr, "swad:questionTag");
	case SOAP_TYPE_swad__answersArray:
		return soap_out_swad__answersArray(soap, tag, id, (const struct swad__answersArray *)ptr, "swad:answersArray");
	case SOAP_TYPE_swad__answer:
		return soap_out_swad__answer(soap, tag, id, (const struct swad__answer *)ptr, "swad:answer");
	case SOAP_TYPE_swad__questionsArray:
		return soap_out_swad__questionsArray(soap, tag, id, (const struct swad__questionsArray *)ptr, "swad:questionsArray");
	case SOAP_TYPE_swad__question:
		return soap_out_swad__question(soap, tag, id, (const struct swad__question *)ptr, "swad:question");
	case SOAP_TYPE_swad__tagsArray:
		return soap_out_swad__tagsArray(soap, tag, id, (const struct swad__tagsArray *)ptr, "swad:tagsArray");
	case SOAP_TYPE_swad__tag:
		return soap_out_swad__tag(soap, tag, id, (const struct swad__tag *)ptr, "swad:tag");
	case SOAP_TYPE_swad__getTestConfigOutput:
		return soap_out_swad__getTestConfigOutput(soap, tag, id, (const struct swad__getTestConfigOutput *)ptr, "swad:getTestConfigOutput");
	case SOAP_TYPE_swad__markNotificationsAsReadOutput:
		return soap_out_swad__markNotificationsAsReadOutput(soap, tag, id, (const struct swad__markNotificationsAsReadOutput *)ptr, "swad:markNotificationsAsReadOutput");
	case SOAP_TYPE_swad__getNotificationsOutput:
		return soap_out_swad__getNotificationsOutput(soap, tag, id, (const struct swad__getNotificationsOutput *)ptr, "swad:getNotificationsOutput");
	case SOAP_TYPE_swad__notificationsArray:
		return soap_out_swad__notificationsArray(soap, tag, id, (const struct swad__notificationsArray *)ptr, "swad:notificationsArray");
	case SOAP_TYPE_swad__notification:
		return soap_out_swad__notification(soap, tag, id, (const struct swad__notification *)ptr, "swad:notification");
	case SOAP_TYPE_swad__sendMyGroupsOutput:
		return soap_out_swad__sendMyGroupsOutput(soap, tag, id, (const struct swad__sendMyGroupsOutput *)ptr, "swad:sendMyGroupsOutput");
	case SOAP_TYPE_swad__getGroupsOutput:
		return soap_out_swad__getGroupsOutput(soap, tag, id, (const struct swad__getGroupsOutput *)ptr, "swad:getGroupsOutput");
	case SOAP_TYPE_swad__groupsArray:
		return soap_out_swad__groupsArray(soap, tag, id, (const struct swad__groupsArray *)ptr, "swad:groupsArray");
	case SOAP_TYPE_swad__group:
		return soap_out_swad__group(soap, tag, id, (const struct swad__group *)ptr, "swad:group");
	case SOAP_TYPE_swad__getGroupTypesOutput:
		return soap_out_swad__getGroupTypesOutput(soap, tag, id, (const struct swad__getGroupTypesOutput *)ptr, "swad:getGroupTypesOutput");
	case SOAP_TYPE_swad__groupTypesArray:
		return soap_out_swad__groupTypesArray(soap, tag, id, (const struct swad__groupTypesArray *)ptr, "swad:groupTypesArray");
	case SOAP_TYPE_swad__groupType:
		return soap_out_swad__groupType(soap, tag, id, (const struct swad__groupType *)ptr, "swad:groupType");
	case SOAP_TYPE_swad__getCourseInfoOutput:
		return soap_out_swad__getCourseInfoOutput(soap, tag, id, (const struct swad__getCourseInfoOutput *)ptr, "swad:getCourseInfoOutput");
	case SOAP_TYPE_swad__getCoursesOutput:
		return soap_out_swad__getCoursesOutput(soap, tag, id, (const struct swad__getCoursesOutput *)ptr, "swad:getCoursesOutput");
	case SOAP_TYPE_swad__coursesArray:
		return soap_out_swad__coursesArray(soap, tag, id, (const struct swad__coursesArray *)ptr, "swad:coursesArray");
	case SOAP_TYPE_swad__course:
		return soap_out_swad__course(soap, tag, id, (const struct swad__course *)ptr, "swad:course");
	case SOAP_TYPE_swad__getNewPasswordOutput:
		return soap_out_swad__getNewPasswordOutput(soap, tag, id, (const struct swad__getNewPasswordOutput *)ptr, "swad:getNewPasswordOutput");
	case SOAP_TYPE_swad__loginByUserPasswordKeyOutput:
		return soap_out_swad__loginByUserPasswordKeyOutput(soap, tag, id, (const struct swad__loginByUserPasswordKeyOutput *)ptr, "swad:loginByUserPasswordKeyOutput");
	case SOAP_TYPE_swad__loginBySessionKeyOutput:
		return soap_out_swad__loginBySessionKeyOutput(soap, tag, id, (const struct swad__loginBySessionKeyOutput *)ptr, "swad:loginBySessionKeyOutput");
	case SOAP_TYPE_swad__createAccountOutput:
		return soap_out_swad__createAccountOutput(soap, tag, id, (const struct swad__createAccountOutput *)ptr, "swad:createAccountOutput");
	case SOAP_TYPE_PointerToswad__sendMessageOutput:
		return soap_out_PointerToswad__sendMessageOutput(soap, tag, id, (struct swad__sendMessageOutput *const*)ptr, "swad:sendMessageOutput");
	case SOAP_TYPE_PointerToswad__sendNoticeOutput:
		return soap_out_PointerToswad__sendNoticeOutput(soap, tag, id, (struct swad__sendNoticeOutput *const*)ptr, "swad:sendNoticeOutput");
	case SOAP_TYPE_PointerToswad__markNotificationsAsReadOutput:
		return soap_out_PointerToswad__markNotificationsAsReadOutput(soap, tag, id, (struct swad__markNotificationsAsReadOutput *const*)ptr, "swad:markNotificationsAsReadOutput");
	case SOAP_TYPE_PointerToswad__getNotificationsOutput:
		return soap_out_PointerToswad__getNotificationsOutput(soap, tag, id, (struct swad__getNotificationsOutput *const*)ptr, "swad:getNotificationsOutput");
	case SOAP_TYPE_PointerToswad__sendAttendanceUsersOutput:
		return soap_out_PointerToswad__sendAttendanceUsersOutput(soap, tag, id, (struct swad__sendAttendanceUsersOutput *const*)ptr, "swad:sendAttendanceUsersOutput");
	case SOAP_TYPE_PointerToswad__getAttendanceUsersOutput:
		return soap_out_PointerToswad__getAttendanceUsersOutput(soap, tag, id, (struct swad__getAttendanceUsersOutput *const*)ptr, "swad:getAttendanceUsersOutput");
	case SOAP_TYPE_PointerToswad__sendAttendanceEventOutput:
		return soap_out_PointerToswad__sendAttendanceEventOutput(soap, tag, id, (struct swad__sendAttendanceEventOutput *const*)ptr, "swad:sendAttendanceEventOutput");
	case SOAP_TYPE_PointerToswad__getAttendanceEventsOutput:
		return soap_out_PointerToswad__getAttendanceEventsOutput(soap, tag, id, (struct swad__getAttendanceEventsOutput *const*)ptr, "swad:getAttendanceEventsOutput");
	case SOAP_TYPE_PointerToswad__getUsersOutput:
		return soap_out_PointerToswad__getUsersOutput(soap, tag, id, (struct swad__getUsersOutput *const*)ptr, "swad:getUsersOutput");
	case SOAP_TYPE_PointerToswad__getTestsOutput:
		return soap_out_PointerToswad__getTestsOutput(soap, tag, id, (struct swad__getTestsOutput *const*)ptr, "swad:getTestsOutput");
	case SOAP_TYPE_PointerToswad__getTestConfigOutput:
		return soap_out_PointerToswad__getTestConfigOutput(soap, tag, id, (struct swad__getTestConfigOutput *const*)ptr, "swad:getTestConfigOutput");
	case SOAP_TYPE_PointerToswad__getMarksOutput:
		return soap_out_PointerToswad__getMarksOutput(soap, tag, id, (struct swad__getMarksOutput *const*)ptr, "swad:getMarksOutput");
	case SOAP_TYPE_PointerToswad__getFileOutput:
		return soap_out_PointerToswad__getFileOutput(soap, tag, id, (struct swad__getFileOutput *const*)ptr, "swad:getFileOutput");
	case SOAP_TYPE_PointerToswad__getDirectoryTreeOutput:
		return soap_out_PointerToswad__getDirectoryTreeOutput(soap, tag, id, (struct swad__getDirectoryTreeOutput *const*)ptr, "swad:getDirectoryTreeOutput");
	case SOAP_TYPE_PointerToswad__sendMyGroupsOutput:
		return soap_out_PointerToswad__sendMyGroupsOutput(soap, tag, id, (struct swad__sendMyGroupsOutput *const*)ptr, "swad:sendMyGroupsOutput");
	case SOAP_TYPE_PointerToswad__getGroupsOutput:
		return soap_out_PointerToswad__getGroupsOutput(soap, tag, id, (struct swad__getGroupsOutput *const*)ptr, "swad:getGroupsOutput");
	case SOAP_TYPE_PointerToswad__getGroupTypesOutput:
		return soap_out_PointerToswad__getGroupTypesOutput(soap, tag, id, (struct swad__getGroupTypesOutput *const*)ptr, "swad:getGroupTypesOutput");
	case SOAP_TYPE_PointerToswad__getCourseInfoOutput:
		return soap_out_PointerToswad__getCourseInfoOutput(soap, tag, id, (struct swad__getCourseInfoOutput *const*)ptr, "swad:getCourseInfoOutput");
	case SOAP_TYPE_PointerToswad__getCoursesOutput:
		return soap_out_PointerToswad__getCoursesOutput(soap, tag, id, (struct swad__getCoursesOutput *const*)ptr, "swad:getCoursesOutput");
	case SOAP_TYPE_PointerToswad__getNewPasswordOutput:
		return soap_out_PointerToswad__getNewPasswordOutput(soap, tag, id, (struct swad__getNewPasswordOutput *const*)ptr, "swad:getNewPasswordOutput");
	case SOAP_TYPE_PointerToswad__loginBySessionKeyOutput:
		return soap_out_PointerToswad__loginBySessionKeyOutput(soap, tag, id, (struct swad__loginBySessionKeyOutput *const*)ptr, "swad:loginBySessionKeyOutput");
	case SOAP_TYPE_PointerToswad__loginByUserPasswordKeyOutput:
		return soap_out_PointerToswad__loginByUserPasswordKeyOutput(soap, tag, id, (struct swad__loginByUserPasswordKeyOutput *const*)ptr, "swad:loginByUserPasswordKeyOutput");
	case SOAP_TYPE_PointerToswad__createAccountOutput:
		return soap_out_PointerToswad__createAccountOutput(soap, tag, id, (struct swad__createAccountOutput *const*)ptr, "swad:createAccountOutput");
	case SOAP_TYPE_PointerToswad__attendanceUser:
		return soap_out_PointerToswad__attendanceUser(soap, tag, id, (struct swad__attendanceUser *const*)ptr, "swad:attendanceUser");
	case SOAP_TYPE_PointerToswad__attendanceEvent:
		return soap_out_PointerToswad__attendanceEvent(soap, tag, id, (struct swad__attendanceEvent *const*)ptr, "swad:attendanceEvent");
	case SOAP_TYPE_PointerToswad__user:
		return soap_out_PointerToswad__user(soap, tag, id, (struct swad__user *const*)ptr, "swad:user");
	case SOAP_TYPE_PointerToswad__questionTag:
		return soap_out_PointerToswad__questionTag(soap, tag, id, (struct swad__questionTag *const*)ptr, "swad:questionTag");
	case SOAP_TYPE_PointerToswad__answer:
		return soap_out_PointerToswad__answer(soap, tag, id, (struct swad__answer *const*)ptr, "swad:answer");
	case SOAP_TYPE_PointerToswad__question:
		return soap_out_PointerToswad__question(soap, tag, id, (struct swad__question *const*)ptr, "swad:question");
	case SOAP_TYPE_PointerToswad__tag:
		return soap_out_PointerToswad__tag(soap, tag, id, (struct swad__tag *const*)ptr, "swad:tag");
	case SOAP_TYPE_PointerToswad__notification:
		return soap_out_PointerToswad__notification(soap, tag, id, (struct swad__notification *const*)ptr, "swad:notification");
	case SOAP_TYPE_PointerToswad__group:
		return soap_out_PointerToswad__group(soap, tag, id, (struct swad__group *const*)ptr, "swad:group");
	case SOAP_TYPE_PointerToswad__groupType:
		return soap_out_PointerToswad__groupType(soap, tag, id, (struct swad__groupType *const*)ptr, "swad:groupType");
	case SOAP_TYPE_PointerToswad__course:
		return soap_out_PointerToswad__course(soap, tag, id, (struct swad__course *const*)ptr, "swad:course");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_swad__sendMessage:
		soap_serialize_swad__sendMessage(soap, (const struct swad__sendMessage *)ptr);
		break;
	case SOAP_TYPE_swad__sendNotice:
		soap_serialize_swad__sendNotice(soap, (const struct swad__sendNotice *)ptr);
		break;
	case SOAP_TYPE_swad__markNotificationsAsRead:
		soap_serialize_swad__markNotificationsAsRead(soap, (const struct swad__markNotificationsAsRead *)ptr);
		break;
	case SOAP_TYPE_swad__getNotifications:
		soap_serialize_swad__getNotifications(soap, (const struct swad__getNotifications *)ptr);
		break;
	case SOAP_TYPE_swad__sendAttendanceUsers:
		soap_serialize_swad__sendAttendanceUsers(soap, (const struct swad__sendAttendanceUsers *)ptr);
		break;
	case SOAP_TYPE_swad__getAttendanceUsers:
		soap_serialize_swad__getAttendanceUsers(soap, (const struct swad__getAttendanceUsers *)ptr);
		break;
	case SOAP_TYPE_swad__sendAttendanceEvent:
		soap_serialize_swad__sendAttendanceEvent(soap, (const struct swad__sendAttendanceEvent *)ptr);
		break;
	case SOAP_TYPE_swad__getAttendanceEvents:
		soap_serialize_swad__getAttendanceEvents(soap, (const struct swad__getAttendanceEvents *)ptr);
		break;
	case SOAP_TYPE_swad__getUsers:
		soap_serialize_swad__getUsers(soap, (const struct swad__getUsers *)ptr);
		break;
	case SOAP_TYPE_swad__getTests:
		soap_serialize_swad__getTests(soap, (const struct swad__getTests *)ptr);
		break;
	case SOAP_TYPE_swad__getTestConfig:
		soap_serialize_swad__getTestConfig(soap, (const struct swad__getTestConfig *)ptr);
		break;
	case SOAP_TYPE_swad__getMarks:
		soap_serialize_swad__getMarks(soap, (const struct swad__getMarks *)ptr);
		break;
	case SOAP_TYPE_swad__getFile:
		soap_serialize_swad__getFile(soap, (const struct swad__getFile *)ptr);
		break;
	case SOAP_TYPE_swad__getDirectoryTree:
		soap_serialize_swad__getDirectoryTree(soap, (const struct swad__getDirectoryTree *)ptr);
		break;
	case SOAP_TYPE_swad__sendMyGroups:
		soap_serialize_swad__sendMyGroups(soap, (const struct swad__sendMyGroups *)ptr);
		break;
	case SOAP_TYPE_swad__getGroups:
		soap_serialize_swad__getGroups(soap, (const struct swad__getGroups *)ptr);
		break;
	case SOAP_TYPE_swad__getGroupTypes:
		soap_serialize_swad__getGroupTypes(soap, (const struct swad__getGroupTypes *)ptr);
		break;
	case SOAP_TYPE_swad__getCourseInfo:
		soap_serialize_swad__getCourseInfo(soap, (const struct swad__getCourseInfo *)ptr);
		break;
	case SOAP_TYPE_swad__getCourses:
		soap_serialize_swad__getCourses(soap, (const struct swad__getCourses *)ptr);
		break;
	case SOAP_TYPE_swad__getNewPassword:
		soap_serialize_swad__getNewPassword(soap, (const struct swad__getNewPassword *)ptr);
		break;
	case SOAP_TYPE_swad__loginBySessionKey:
		soap_serialize_swad__loginBySessionKey(soap, (const struct swad__loginBySessionKey *)ptr);
		break;
	case SOAP_TYPE_swad__loginByUserPasswordKey:
		soap_serialize_swad__loginByUserPasswordKey(soap, (const struct swad__loginByUserPasswordKey *)ptr);
		break;
	case SOAP_TYPE_swad__createAccount:
		soap_serialize_swad__createAccount(soap, (const struct swad__createAccount *)ptr);
		break;
	case SOAP_TYPE_swad__sendMessageOutput:
		soap_serialize_swad__sendMessageOutput(soap, (const struct swad__sendMessageOutput *)ptr);
		break;
	case SOAP_TYPE_swad__sendNoticeOutput:
		soap_serialize_swad__sendNoticeOutput(soap, (const struct swad__sendNoticeOutput *)ptr);
		break;
	case SOAP_TYPE_swad__getMarksOutput:
		soap_serialize_swad__getMarksOutput(soap, (const struct swad__getMarksOutput *)ptr);
		break;
	case SOAP_TYPE_swad__getFileOutput:
		soap_serialize_swad__getFileOutput(soap, (const struct swad__getFileOutput *)ptr);
		break;
	case SOAP_TYPE_swad__getDirectoryTreeOutput:
		soap_serialize_swad__getDirectoryTreeOutput(soap, (const struct swad__getDirectoryTreeOutput *)ptr);
		break;
	case SOAP_TYPE_swad__sendAttendanceUsersOutput:
		soap_serialize_swad__sendAttendanceUsersOutput(soap, (const struct swad__sendAttendanceUsersOutput *)ptr);
		break;
	case SOAP_TYPE_swad__getAttendanceUsersOutput:
		soap_serialize_swad__getAttendanceUsersOutput(soap, (const struct swad__getAttendanceUsersOutput *)ptr);
		break;
	case SOAP_TYPE_swad__attendanceUsersArray:
		soap_serialize_swad__attendanceUsersArray(soap, (const struct swad__attendanceUsersArray *)ptr);
		break;
	case SOAP_TYPE_swad__attendanceUser:
		soap_serialize_swad__attendanceUser(soap, (const struct swad__attendanceUser *)ptr);
		break;
	case SOAP_TYPE_swad__sendAttendanceEventOutput:
		soap_serialize_swad__sendAttendanceEventOutput(soap, (const struct swad__sendAttendanceEventOutput *)ptr);
		break;
	case SOAP_TYPE_swad__getAttendanceEventsOutput:
		soap_serialize_swad__getAttendanceEventsOutput(soap, (const struct swad__getAttendanceEventsOutput *)ptr);
		break;
	case SOAP_TYPE_swad__attendanceEventsArray:
		soap_serialize_swad__attendanceEventsArray(soap, (const struct swad__attendanceEventsArray *)ptr);
		break;
	case SOAP_TYPE_swad__attendanceEvent:
		soap_serialize_swad__attendanceEvent(soap, (const struct swad__attendanceEvent *)ptr);
		break;
	case SOAP_TYPE_swad__getUsersOutput:
		soap_serialize_swad__getUsersOutput(soap, (const struct swad__getUsersOutput *)ptr);
		break;
	case SOAP_TYPE_swad__usersArray:
		soap_serialize_swad__usersArray(soap, (const struct swad__usersArray *)ptr);
		break;
	case SOAP_TYPE_swad__user:
		soap_serialize_swad__user(soap, (const struct swad__user *)ptr);
		break;
	case SOAP_TYPE_swad__getTestsOutput:
		soap_serialize_swad__getTestsOutput(soap, (const struct swad__getTestsOutput *)ptr);
		break;
	case SOAP_TYPE_swad__questionTagsArray:
		soap_serialize_swad__questionTagsArray(soap, (const struct swad__questionTagsArray *)ptr);
		break;
	case SOAP_TYPE_swad__questionTag:
		soap_serialize_swad__questionTag(soap, (const struct swad__questionTag *)ptr);
		break;
	case SOAP_TYPE_swad__answersArray:
		soap_serialize_swad__answersArray(soap, (const struct swad__answersArray *)ptr);
		break;
	case SOAP_TYPE_swad__answer:
		soap_serialize_swad__answer(soap, (const struct swad__answer *)ptr);
		break;
	case SOAP_TYPE_swad__questionsArray:
		soap_serialize_swad__questionsArray(soap, (const struct swad__questionsArray *)ptr);
		break;
	case SOAP_TYPE_swad__question:
		soap_serialize_swad__question(soap, (const struct swad__question *)ptr);
		break;
	case SOAP_TYPE_swad__tagsArray:
		soap_serialize_swad__tagsArray(soap, (const struct swad__tagsArray *)ptr);
		break;
	case SOAP_TYPE_swad__tag:
		soap_serialize_swad__tag(soap, (const struct swad__tag *)ptr);
		break;
	case SOAP_TYPE_swad__getTestConfigOutput:
		soap_serialize_swad__getTestConfigOutput(soap, (const struct swad__getTestConfigOutput *)ptr);
		break;
	case SOAP_TYPE_swad__markNotificationsAsReadOutput:
		soap_serialize_swad__markNotificationsAsReadOutput(soap, (const struct swad__markNotificationsAsReadOutput *)ptr);
		break;
	case SOAP_TYPE_swad__getNotificationsOutput:
		soap_serialize_swad__getNotificationsOutput(soap, (const struct swad__getNotificationsOutput *)ptr);
		break;
	case SOAP_TYPE_swad__notificationsArray:
		soap_serialize_swad__notificationsArray(soap, (const struct swad__notificationsArray *)ptr);
		break;
	case SOAP_TYPE_swad__notification:
		soap_serialize_swad__notification(soap, (const struct swad__notification *)ptr);
		break;
	case SOAP_TYPE_swad__sendMyGroupsOutput:
		soap_serialize_swad__sendMyGroupsOutput(soap, (const struct swad__sendMyGroupsOutput *)ptr);
		break;
	case SOAP_TYPE_swad__getGroupsOutput:
		soap_serialize_swad__getGroupsOutput(soap, (const struct swad__getGroupsOutput *)ptr);
		break;
	case SOAP_TYPE_swad__groupsArray:
		soap_serialize_swad__groupsArray(soap, (const struct swad__groupsArray *)ptr);
		break;
	case SOAP_TYPE_swad__group:
		soap_serialize_swad__group(soap, (const struct swad__group *)ptr);
		break;
	case SOAP_TYPE_swad__getGroupTypesOutput:
		soap_serialize_swad__getGroupTypesOutput(soap, (const struct swad__getGroupTypesOutput *)ptr);
		break;
	case SOAP_TYPE_swad__groupTypesArray:
		soap_serialize_swad__groupTypesArray(soap, (const struct swad__groupTypesArray *)ptr);
		break;
	case SOAP_TYPE_swad__groupType:
		soap_serialize_swad__groupType(soap, (const struct swad__groupType *)ptr);
		break;
	case SOAP_TYPE_swad__getCourseInfoOutput:
		soap_serialize_swad__getCourseInfoOutput(soap, (const struct swad__getCourseInfoOutput *)ptr);
		break;
	case SOAP_TYPE_swad__getCoursesOutput:
		soap_serialize_swad__getCoursesOutput(soap, (const struct swad__getCoursesOutput *)ptr);
		break;
	case SOAP_TYPE_swad__coursesArray:
		soap_serialize_swad__coursesArray(soap, (const struct swad__coursesArray *)ptr);
		break;
	case SOAP_TYPE_swad__course:
		soap_serialize_swad__course(soap, (const struct swad__course *)ptr);
		break;
	case SOAP_TYPE_swad__getNewPasswordOutput:
		soap_serialize_swad__getNewPasswordOutput(soap, (const struct swad__getNewPasswordOutput *)ptr);
		break;
	case SOAP_TYPE_swad__loginByUserPasswordKeyOutput:
		soap_serialize_swad__loginByUserPasswordKeyOutput(soap, (const struct swad__loginByUserPasswordKeyOutput *)ptr);
		break;
	case SOAP_TYPE_swad__loginBySessionKeyOutput:
		soap_serialize_swad__loginBySessionKeyOutput(soap, (const struct swad__loginBySessionKeyOutput *)ptr);
		break;
	case SOAP_TYPE_swad__createAccountOutput:
		soap_serialize_swad__createAccountOutput(soap, (const struct swad__createAccountOutput *)ptr);
		break;
	case SOAP_TYPE_PointerToswad__sendMessageOutput:
		soap_serialize_PointerToswad__sendMessageOutput(soap, (struct swad__sendMessageOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__sendNoticeOutput:
		soap_serialize_PointerToswad__sendNoticeOutput(soap, (struct swad__sendNoticeOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__markNotificationsAsReadOutput:
		soap_serialize_PointerToswad__markNotificationsAsReadOutput(soap, (struct swad__markNotificationsAsReadOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__getNotificationsOutput:
		soap_serialize_PointerToswad__getNotificationsOutput(soap, (struct swad__getNotificationsOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__sendAttendanceUsersOutput:
		soap_serialize_PointerToswad__sendAttendanceUsersOutput(soap, (struct swad__sendAttendanceUsersOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__getAttendanceUsersOutput:
		soap_serialize_PointerToswad__getAttendanceUsersOutput(soap, (struct swad__getAttendanceUsersOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__sendAttendanceEventOutput:
		soap_serialize_PointerToswad__sendAttendanceEventOutput(soap, (struct swad__sendAttendanceEventOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__getAttendanceEventsOutput:
		soap_serialize_PointerToswad__getAttendanceEventsOutput(soap, (struct swad__getAttendanceEventsOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__getUsersOutput:
		soap_serialize_PointerToswad__getUsersOutput(soap, (struct swad__getUsersOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__getTestsOutput:
		soap_serialize_PointerToswad__getTestsOutput(soap, (struct swad__getTestsOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__getTestConfigOutput:
		soap_serialize_PointerToswad__getTestConfigOutput(soap, (struct swad__getTestConfigOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__getMarksOutput:
		soap_serialize_PointerToswad__getMarksOutput(soap, (struct swad__getMarksOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__getFileOutput:
		soap_serialize_PointerToswad__getFileOutput(soap, (struct swad__getFileOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__getDirectoryTreeOutput:
		soap_serialize_PointerToswad__getDirectoryTreeOutput(soap, (struct swad__getDirectoryTreeOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__sendMyGroupsOutput:
		soap_serialize_PointerToswad__sendMyGroupsOutput(soap, (struct swad__sendMyGroupsOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__getGroupsOutput:
		soap_serialize_PointerToswad__getGroupsOutput(soap, (struct swad__getGroupsOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__getGroupTypesOutput:
		soap_serialize_PointerToswad__getGroupTypesOutput(soap, (struct swad__getGroupTypesOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__getCourseInfoOutput:
		soap_serialize_PointerToswad__getCourseInfoOutput(soap, (struct swad__getCourseInfoOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__getCoursesOutput:
		soap_serialize_PointerToswad__getCoursesOutput(soap, (struct swad__getCoursesOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__getNewPasswordOutput:
		soap_serialize_PointerToswad__getNewPasswordOutput(soap, (struct swad__getNewPasswordOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__loginBySessionKeyOutput:
		soap_serialize_PointerToswad__loginBySessionKeyOutput(soap, (struct swad__loginBySessionKeyOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__loginByUserPasswordKeyOutput:
		soap_serialize_PointerToswad__loginByUserPasswordKeyOutput(soap, (struct swad__loginByUserPasswordKeyOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__createAccountOutput:
		soap_serialize_PointerToswad__createAccountOutput(soap, (struct swad__createAccountOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__attendanceUser:
		soap_serialize_PointerToswad__attendanceUser(soap, (struct swad__attendanceUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__attendanceEvent:
		soap_serialize_PointerToswad__attendanceEvent(soap, (struct swad__attendanceEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__user:
		soap_serialize_PointerToswad__user(soap, (struct swad__user *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__questionTag:
		soap_serialize_PointerToswad__questionTag(soap, (struct swad__questionTag *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__answer:
		soap_serialize_PointerToswad__answer(soap, (struct swad__answer *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__question:
		soap_serialize_PointerToswad__question(soap, (struct swad__question *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__tag:
		soap_serialize_PointerToswad__tag(soap, (struct swad__tag *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__notification:
		soap_serialize_PointerToswad__notification(soap, (struct swad__notification *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__group:
		soap_serialize_PointerToswad__group(soap, (struct swad__group *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__groupType:
		soap_serialize_PointerToswad__groupType(soap, (struct swad__groupType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToswad__course:
		soap_serialize_PointerToswad__course(soap, (struct swad__course *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_long(struct soap *soap, long *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_long
	*a = SOAP_DEFAULT_long;
#else
	*a = (long)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_long(struct soap *soap, const char *tag, int id, const long *a, const char *type)
{
	return soap_outlong(soap, tag, id, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_in_long(struct soap *soap, const char *tag, long *a, const char *type)
{	long *p;
	p = soap_inlong(soap, tag, a, type, SOAP_TYPE_long);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_long(struct soap *soap, const long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_long);
	if (soap_out_long(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_get_long(struct soap *soap, long *p, const char *tag, const char *type)
{
	if ((p = soap_in_long(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__sendMessage(struct soap *soap, struct swad__sendMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsKey);
	soap_default_int(soap, &a->messageCode);
	soap_default_string(soap, &a->to);
	soap_default_string(soap, &a->subject);
	soap_default_string(soap, &a->body);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__sendMessage(struct soap *soap, const struct swad__sendMessage *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsKey);
	soap_serialize_string(soap, &a->to);
	soap_serialize_string(soap, &a->subject);
	soap_serialize_string(soap, &a->body);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__sendMessage(struct soap *soap, const char *tag, int id, const struct swad__sendMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__sendMessage), type))
		return soap->error;
	if (soap_out_string(soap, "wsKey", -1, &a->wsKey, ""))
		return soap->error;
	if (soap_out_int(soap, "messageCode", -1, &a->messageCode, ""))
		return soap->error;
	if (soap_out_string(soap, "to", -1, &a->to, ""))
		return soap->error;
	if (soap_out_string(soap, "subject", -1, &a->subject, ""))
		return soap->error;
	if (soap_out_string(soap, "body", -1, &a->body, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__sendMessage * SOAP_FMAC4 soap_in_swad__sendMessage(struct soap *soap, const char *tag, struct swad__sendMessage *a, const char *type)
{
	size_t soap_flag_wsKey = 1;
	size_t soap_flag_messageCode = 1;
	size_t soap_flag_to = 1;
	size_t soap_flag_subject = 1;
	size_t soap_flag_body = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__sendMessage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__sendMessage, sizeof(struct swad__sendMessage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__sendMessage(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsKey", &a->wsKey, "xsd:string"))
				{	soap_flag_wsKey--;
					continue;
				}
			if (soap_flag_messageCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "messageCode", &a->messageCode, "xsd:int"))
				{	soap_flag_messageCode--;
					continue;
				}
			if (soap_flag_to && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "to", &a->to, "xsd:string"))
				{	soap_flag_to--;
					continue;
				}
			if (soap_flag_subject && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "subject", &a->subject, "xsd:string"))
				{	soap_flag_subject--;
					continue;
				}
			if (soap_flag_body && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "body", &a->body, "xsd:string"))
				{	soap_flag_body--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__sendMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__sendMessage, 0, sizeof(struct swad__sendMessage), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_messageCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__sendMessage(struct soap *soap, const struct swad__sendMessage *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__sendMessage);
	if (soap_out_swad__sendMessage(soap, tag?tag:"swad:sendMessage", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__sendMessage * SOAP_FMAC4 soap_get_swad__sendMessage(struct soap *soap, struct swad__sendMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__sendMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__sendNotice(struct soap *soap, struct swad__sendNotice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsKey);
	soap_default_int(soap, &a->courseCode);
	soap_default_string(soap, &a->body);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__sendNotice(struct soap *soap, const struct swad__sendNotice *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsKey);
	soap_serialize_string(soap, &a->body);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__sendNotice(struct soap *soap, const char *tag, int id, const struct swad__sendNotice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__sendNotice), type))
		return soap->error;
	if (soap_out_string(soap, "wsKey", -1, &a->wsKey, ""))
		return soap->error;
	if (soap_out_int(soap, "courseCode", -1, &a->courseCode, ""))
		return soap->error;
	if (soap_out_string(soap, "body", -1, &a->body, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__sendNotice * SOAP_FMAC4 soap_in_swad__sendNotice(struct soap *soap, const char *tag, struct swad__sendNotice *a, const char *type)
{
	size_t soap_flag_wsKey = 1;
	size_t soap_flag_courseCode = 1;
	size_t soap_flag_body = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__sendNotice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__sendNotice, sizeof(struct swad__sendNotice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__sendNotice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsKey", &a->wsKey, "xsd:string"))
				{	soap_flag_wsKey--;
					continue;
				}
			if (soap_flag_courseCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "courseCode", &a->courseCode, "xsd:int"))
				{	soap_flag_courseCode--;
					continue;
				}
			if (soap_flag_body && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "body", &a->body, "xsd:string"))
				{	soap_flag_body--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__sendNotice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__sendNotice, 0, sizeof(struct swad__sendNotice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_courseCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__sendNotice(struct soap *soap, const struct swad__sendNotice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__sendNotice);
	if (soap_out_swad__sendNotice(soap, tag?tag:"swad:sendNotice", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__sendNotice * SOAP_FMAC4 soap_get_swad__sendNotice(struct soap *soap, struct swad__sendNotice *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__sendNotice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__markNotificationsAsRead(struct soap *soap, struct swad__markNotificationsAsRead *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsKey);
	soap_default_string(soap, &a->notifications);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__markNotificationsAsRead(struct soap *soap, const struct swad__markNotificationsAsRead *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsKey);
	soap_serialize_string(soap, &a->notifications);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__markNotificationsAsRead(struct soap *soap, const char *tag, int id, const struct swad__markNotificationsAsRead *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__markNotificationsAsRead), type))
		return soap->error;
	if (soap_out_string(soap, "wsKey", -1, &a->wsKey, ""))
		return soap->error;
	if (soap_out_string(soap, "notifications", -1, &a->notifications, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__markNotificationsAsRead * SOAP_FMAC4 soap_in_swad__markNotificationsAsRead(struct soap *soap, const char *tag, struct swad__markNotificationsAsRead *a, const char *type)
{
	size_t soap_flag_wsKey = 1;
	size_t soap_flag_notifications = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__markNotificationsAsRead *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__markNotificationsAsRead, sizeof(struct swad__markNotificationsAsRead), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__markNotificationsAsRead(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsKey", &a->wsKey, "xsd:string"))
				{	soap_flag_wsKey--;
					continue;
				}
			if (soap_flag_notifications && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "notifications", &a->notifications, "xsd:string"))
				{	soap_flag_notifications--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__markNotificationsAsRead *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__markNotificationsAsRead, 0, sizeof(struct swad__markNotificationsAsRead), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__markNotificationsAsRead(struct soap *soap, const struct swad__markNotificationsAsRead *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__markNotificationsAsRead);
	if (soap_out_swad__markNotificationsAsRead(soap, tag?tag:"swad:markNotificationsAsRead", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__markNotificationsAsRead * SOAP_FMAC4 soap_get_swad__markNotificationsAsRead(struct soap *soap, struct swad__markNotificationsAsRead *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__markNotificationsAsRead(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getNotifications(struct soap *soap, struct swad__getNotifications *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsKey);
	soap_default_long(soap, &a->beginTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getNotifications(struct soap *soap, const struct swad__getNotifications *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getNotifications(struct soap *soap, const char *tag, int id, const struct swad__getNotifications *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getNotifications), type))
		return soap->error;
	if (soap_out_string(soap, "wsKey", -1, &a->wsKey, ""))
		return soap->error;
	if (soap_out_long(soap, "beginTime", -1, &a->beginTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getNotifications * SOAP_FMAC4 soap_in_swad__getNotifications(struct soap *soap, const char *tag, struct swad__getNotifications *a, const char *type)
{
	size_t soap_flag_wsKey = 1;
	size_t soap_flag_beginTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getNotifications *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getNotifications, sizeof(struct swad__getNotifications), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getNotifications(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsKey", &a->wsKey, "xsd:string"))
				{	soap_flag_wsKey--;
					continue;
				}
			if (soap_flag_beginTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "beginTime", &a->beginTime, "xsd:long"))
				{	soap_flag_beginTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getNotifications *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getNotifications, 0, sizeof(struct swad__getNotifications), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_beginTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getNotifications(struct soap *soap, const struct swad__getNotifications *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getNotifications);
	if (soap_out_swad__getNotifications(soap, tag?tag:"swad:getNotifications", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getNotifications * SOAP_FMAC4 soap_get_swad__getNotifications(struct soap *soap, struct swad__getNotifications *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getNotifications(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__sendAttendanceUsers(struct soap *soap, struct swad__sendAttendanceUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsKey);
	soap_default_int(soap, &a->attendanceEventCode);
	soap_default_string(soap, &a->users);
	soap_default_int(soap, &a->setOthersAsAbsent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__sendAttendanceUsers(struct soap *soap, const struct swad__sendAttendanceUsers *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsKey);
	soap_serialize_string(soap, &a->users);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__sendAttendanceUsers(struct soap *soap, const char *tag, int id, const struct swad__sendAttendanceUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__sendAttendanceUsers), type))
		return soap->error;
	if (soap_out_string(soap, "wsKey", -1, &a->wsKey, ""))
		return soap->error;
	if (soap_out_int(soap, "attendanceEventCode", -1, &a->attendanceEventCode, ""))
		return soap->error;
	if (soap_out_string(soap, "users", -1, &a->users, ""))
		return soap->error;
	if (soap_out_int(soap, "setOthersAsAbsent", -1, &a->setOthersAsAbsent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__sendAttendanceUsers * SOAP_FMAC4 soap_in_swad__sendAttendanceUsers(struct soap *soap, const char *tag, struct swad__sendAttendanceUsers *a, const char *type)
{
	size_t soap_flag_wsKey = 1;
	size_t soap_flag_attendanceEventCode = 1;
	size_t soap_flag_users = 1;
	size_t soap_flag_setOthersAsAbsent = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__sendAttendanceUsers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__sendAttendanceUsers, sizeof(struct swad__sendAttendanceUsers), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__sendAttendanceUsers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsKey", &a->wsKey, "xsd:string"))
				{	soap_flag_wsKey--;
					continue;
				}
			if (soap_flag_attendanceEventCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "attendanceEventCode", &a->attendanceEventCode, "xsd:int"))
				{	soap_flag_attendanceEventCode--;
					continue;
				}
			if (soap_flag_users && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "users", &a->users, "xsd:string"))
				{	soap_flag_users--;
					continue;
				}
			if (soap_flag_setOthersAsAbsent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "setOthersAsAbsent", &a->setOthersAsAbsent, "xsd:int"))
				{	soap_flag_setOthersAsAbsent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__sendAttendanceUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__sendAttendanceUsers, 0, sizeof(struct swad__sendAttendanceUsers), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_attendanceEventCode > 0 || soap_flag_setOthersAsAbsent > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__sendAttendanceUsers(struct soap *soap, const struct swad__sendAttendanceUsers *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__sendAttendanceUsers);
	if (soap_out_swad__sendAttendanceUsers(soap, tag?tag:"swad:sendAttendanceUsers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__sendAttendanceUsers * SOAP_FMAC4 soap_get_swad__sendAttendanceUsers(struct soap *soap, struct swad__sendAttendanceUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__sendAttendanceUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getAttendanceUsers(struct soap *soap, struct swad__getAttendanceUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsKey);
	soap_default_int(soap, &a->attendanceEventCode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getAttendanceUsers(struct soap *soap, const struct swad__getAttendanceUsers *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getAttendanceUsers(struct soap *soap, const char *tag, int id, const struct swad__getAttendanceUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getAttendanceUsers), type))
		return soap->error;
	if (soap_out_string(soap, "wsKey", -1, &a->wsKey, ""))
		return soap->error;
	if (soap_out_int(soap, "attendanceEventCode", -1, &a->attendanceEventCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getAttendanceUsers * SOAP_FMAC4 soap_in_swad__getAttendanceUsers(struct soap *soap, const char *tag, struct swad__getAttendanceUsers *a, const char *type)
{
	size_t soap_flag_wsKey = 1;
	size_t soap_flag_attendanceEventCode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getAttendanceUsers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getAttendanceUsers, sizeof(struct swad__getAttendanceUsers), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getAttendanceUsers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsKey", &a->wsKey, "xsd:string"))
				{	soap_flag_wsKey--;
					continue;
				}
			if (soap_flag_attendanceEventCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "attendanceEventCode", &a->attendanceEventCode, "xsd:int"))
				{	soap_flag_attendanceEventCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getAttendanceUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getAttendanceUsers, 0, sizeof(struct swad__getAttendanceUsers), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_attendanceEventCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getAttendanceUsers(struct soap *soap, const struct swad__getAttendanceUsers *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getAttendanceUsers);
	if (soap_out_swad__getAttendanceUsers(soap, tag?tag:"swad:getAttendanceUsers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getAttendanceUsers * SOAP_FMAC4 soap_get_swad__getAttendanceUsers(struct soap *soap, struct swad__getAttendanceUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getAttendanceUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__sendAttendanceEvent(struct soap *soap, struct swad__sendAttendanceEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsKey);
	soap_default_int(soap, &a->attendanceEventCode);
	soap_default_int(soap, &a->courseCode);
	soap_default_int(soap, &a->hidden);
	soap_default_int(soap, &a->startTime);
	soap_default_int(soap, &a->endTime);
	soap_default_int(soap, &a->commentsTeachersVisible);
	soap_default_string(soap, &a->title);
	soap_default_string(soap, &a->text);
	soap_default_string(soap, &a->groups);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__sendAttendanceEvent(struct soap *soap, const struct swad__sendAttendanceEvent *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsKey);
	soap_serialize_string(soap, &a->title);
	soap_serialize_string(soap, &a->text);
	soap_serialize_string(soap, &a->groups);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__sendAttendanceEvent(struct soap *soap, const char *tag, int id, const struct swad__sendAttendanceEvent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__sendAttendanceEvent), type))
		return soap->error;
	if (soap_out_string(soap, "wsKey", -1, &a->wsKey, ""))
		return soap->error;
	if (soap_out_int(soap, "attendanceEventCode", -1, &a->attendanceEventCode, ""))
		return soap->error;
	if (soap_out_int(soap, "courseCode", -1, &a->courseCode, ""))
		return soap->error;
	if (soap_out_int(soap, "hidden", -1, &a->hidden, ""))
		return soap->error;
	if (soap_out_int(soap, "startTime", -1, &a->startTime, ""))
		return soap->error;
	if (soap_out_int(soap, "endTime", -1, &a->endTime, ""))
		return soap->error;
	if (soap_out_int(soap, "commentsTeachersVisible", -1, &a->commentsTeachersVisible, ""))
		return soap->error;
	if (soap_out_string(soap, "title", -1, &a->title, ""))
		return soap->error;
	if (soap_out_string(soap, "text", -1, &a->text, ""))
		return soap->error;
	if (soap_out_string(soap, "groups", -1, &a->groups, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__sendAttendanceEvent * SOAP_FMAC4 soap_in_swad__sendAttendanceEvent(struct soap *soap, const char *tag, struct swad__sendAttendanceEvent *a, const char *type)
{
	size_t soap_flag_wsKey = 1;
	size_t soap_flag_attendanceEventCode = 1;
	size_t soap_flag_courseCode = 1;
	size_t soap_flag_hidden = 1;
	size_t soap_flag_startTime = 1;
	size_t soap_flag_endTime = 1;
	size_t soap_flag_commentsTeachersVisible = 1;
	size_t soap_flag_title = 1;
	size_t soap_flag_text = 1;
	size_t soap_flag_groups = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__sendAttendanceEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__sendAttendanceEvent, sizeof(struct swad__sendAttendanceEvent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__sendAttendanceEvent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsKey", &a->wsKey, "xsd:string"))
				{	soap_flag_wsKey--;
					continue;
				}
			if (soap_flag_attendanceEventCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "attendanceEventCode", &a->attendanceEventCode, "xsd:int"))
				{	soap_flag_attendanceEventCode--;
					continue;
				}
			if (soap_flag_courseCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "courseCode", &a->courseCode, "xsd:int"))
				{	soap_flag_courseCode--;
					continue;
				}
			if (soap_flag_hidden && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "hidden", &a->hidden, "xsd:int"))
				{	soap_flag_hidden--;
					continue;
				}
			if (soap_flag_startTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "startTime", &a->startTime, "xsd:int"))
				{	soap_flag_startTime--;
					continue;
				}
			if (soap_flag_endTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "endTime", &a->endTime, "xsd:int"))
				{	soap_flag_endTime--;
					continue;
				}
			if (soap_flag_commentsTeachersVisible && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "commentsTeachersVisible", &a->commentsTeachersVisible, "xsd:int"))
				{	soap_flag_commentsTeachersVisible--;
					continue;
				}
			if (soap_flag_title && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "title", &a->title, "xsd:string"))
				{	soap_flag_title--;
					continue;
				}
			if (soap_flag_text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "text", &a->text, "xsd:string"))
				{	soap_flag_text--;
					continue;
				}
			if (soap_flag_groups && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "groups", &a->groups, "xsd:string"))
				{	soap_flag_groups--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__sendAttendanceEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__sendAttendanceEvent, 0, sizeof(struct swad__sendAttendanceEvent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_attendanceEventCode > 0 || soap_flag_courseCode > 0 || soap_flag_hidden > 0 || soap_flag_startTime > 0 || soap_flag_endTime > 0 || soap_flag_commentsTeachersVisible > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__sendAttendanceEvent(struct soap *soap, const struct swad__sendAttendanceEvent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__sendAttendanceEvent);
	if (soap_out_swad__sendAttendanceEvent(soap, tag?tag:"swad:sendAttendanceEvent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__sendAttendanceEvent * SOAP_FMAC4 soap_get_swad__sendAttendanceEvent(struct soap *soap, struct swad__sendAttendanceEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__sendAttendanceEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getAttendanceEvents(struct soap *soap, struct swad__getAttendanceEvents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsKey);
	soap_default_int(soap, &a->courseCode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getAttendanceEvents(struct soap *soap, const struct swad__getAttendanceEvents *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getAttendanceEvents(struct soap *soap, const char *tag, int id, const struct swad__getAttendanceEvents *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getAttendanceEvents), type))
		return soap->error;
	if (soap_out_string(soap, "wsKey", -1, &a->wsKey, ""))
		return soap->error;
	if (soap_out_int(soap, "courseCode", -1, &a->courseCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getAttendanceEvents * SOAP_FMAC4 soap_in_swad__getAttendanceEvents(struct soap *soap, const char *tag, struct swad__getAttendanceEvents *a, const char *type)
{
	size_t soap_flag_wsKey = 1;
	size_t soap_flag_courseCode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getAttendanceEvents *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getAttendanceEvents, sizeof(struct swad__getAttendanceEvents), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getAttendanceEvents(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsKey", &a->wsKey, "xsd:string"))
				{	soap_flag_wsKey--;
					continue;
				}
			if (soap_flag_courseCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "courseCode", &a->courseCode, "xsd:int"))
				{	soap_flag_courseCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getAttendanceEvents *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getAttendanceEvents, 0, sizeof(struct swad__getAttendanceEvents), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_courseCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getAttendanceEvents(struct soap *soap, const struct swad__getAttendanceEvents *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getAttendanceEvents);
	if (soap_out_swad__getAttendanceEvents(soap, tag?tag:"swad:getAttendanceEvents", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getAttendanceEvents * SOAP_FMAC4 soap_get_swad__getAttendanceEvents(struct soap *soap, struct swad__getAttendanceEvents *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getAttendanceEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getUsers(struct soap *soap, struct swad__getUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsKey);
	soap_default_int(soap, &a->courseCode);
	soap_default_int(soap, &a->groupCode);
	soap_default_int(soap, &a->userRole);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getUsers(struct soap *soap, const struct swad__getUsers *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getUsers(struct soap *soap, const char *tag, int id, const struct swad__getUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getUsers), type))
		return soap->error;
	if (soap_out_string(soap, "wsKey", -1, &a->wsKey, ""))
		return soap->error;
	if (soap_out_int(soap, "courseCode", -1, &a->courseCode, ""))
		return soap->error;
	if (soap_out_int(soap, "groupCode", -1, &a->groupCode, ""))
		return soap->error;
	if (soap_out_int(soap, "userRole", -1, &a->userRole, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getUsers * SOAP_FMAC4 soap_in_swad__getUsers(struct soap *soap, const char *tag, struct swad__getUsers *a, const char *type)
{
	size_t soap_flag_wsKey = 1;
	size_t soap_flag_courseCode = 1;
	size_t soap_flag_groupCode = 1;
	size_t soap_flag_userRole = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getUsers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getUsers, sizeof(struct swad__getUsers), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getUsers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsKey", &a->wsKey, "xsd:string"))
				{	soap_flag_wsKey--;
					continue;
				}
			if (soap_flag_courseCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "courseCode", &a->courseCode, "xsd:int"))
				{	soap_flag_courseCode--;
					continue;
				}
			if (soap_flag_groupCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "groupCode", &a->groupCode, "xsd:int"))
				{	soap_flag_groupCode--;
					continue;
				}
			if (soap_flag_userRole && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "userRole", &a->userRole, "xsd:int"))
				{	soap_flag_userRole--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getUsers, 0, sizeof(struct swad__getUsers), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_courseCode > 0 || soap_flag_groupCode > 0 || soap_flag_userRole > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getUsers(struct soap *soap, const struct swad__getUsers *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getUsers);
	if (soap_out_swad__getUsers(soap, tag?tag:"swad:getUsers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getUsers * SOAP_FMAC4 soap_get_swad__getUsers(struct soap *soap, struct swad__getUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getTests(struct soap *soap, struct swad__getTests *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsKey);
	soap_default_int(soap, &a->courseCode);
	soap_default_long(soap, &a->beginTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getTests(struct soap *soap, const struct swad__getTests *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getTests(struct soap *soap, const char *tag, int id, const struct swad__getTests *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getTests), type))
		return soap->error;
	if (soap_out_string(soap, "wsKey", -1, &a->wsKey, ""))
		return soap->error;
	if (soap_out_int(soap, "courseCode", -1, &a->courseCode, ""))
		return soap->error;
	if (soap_out_long(soap, "beginTime", -1, &a->beginTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getTests * SOAP_FMAC4 soap_in_swad__getTests(struct soap *soap, const char *tag, struct swad__getTests *a, const char *type)
{
	size_t soap_flag_wsKey = 1;
	size_t soap_flag_courseCode = 1;
	size_t soap_flag_beginTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getTests *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getTests, sizeof(struct swad__getTests), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getTests(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsKey", &a->wsKey, "xsd:string"))
				{	soap_flag_wsKey--;
					continue;
				}
			if (soap_flag_courseCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "courseCode", &a->courseCode, "xsd:int"))
				{	soap_flag_courseCode--;
					continue;
				}
			if (soap_flag_beginTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "beginTime", &a->beginTime, "xsd:long"))
				{	soap_flag_beginTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getTests *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getTests, 0, sizeof(struct swad__getTests), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_courseCode > 0 || soap_flag_beginTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getTests(struct soap *soap, const struct swad__getTests *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getTests);
	if (soap_out_swad__getTests(soap, tag?tag:"swad:getTests", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getTests * SOAP_FMAC4 soap_get_swad__getTests(struct soap *soap, struct swad__getTests *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getTests(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getTestConfig(struct soap *soap, struct swad__getTestConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsKey);
	soap_default_int(soap, &a->courseCode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getTestConfig(struct soap *soap, const struct swad__getTestConfig *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getTestConfig(struct soap *soap, const char *tag, int id, const struct swad__getTestConfig *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getTestConfig), type))
		return soap->error;
	if (soap_out_string(soap, "wsKey", -1, &a->wsKey, ""))
		return soap->error;
	if (soap_out_int(soap, "courseCode", -1, &a->courseCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getTestConfig * SOAP_FMAC4 soap_in_swad__getTestConfig(struct soap *soap, const char *tag, struct swad__getTestConfig *a, const char *type)
{
	size_t soap_flag_wsKey = 1;
	size_t soap_flag_courseCode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getTestConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getTestConfig, sizeof(struct swad__getTestConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getTestConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsKey", &a->wsKey, "xsd:string"))
				{	soap_flag_wsKey--;
					continue;
				}
			if (soap_flag_courseCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "courseCode", &a->courseCode, "xsd:int"))
				{	soap_flag_courseCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getTestConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getTestConfig, 0, sizeof(struct swad__getTestConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_courseCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getTestConfig(struct soap *soap, const struct swad__getTestConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getTestConfig);
	if (soap_out_swad__getTestConfig(soap, tag?tag:"swad:getTestConfig", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getTestConfig * SOAP_FMAC4 soap_get_swad__getTestConfig(struct soap *soap, struct swad__getTestConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getTestConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getMarks(struct soap *soap, struct swad__getMarks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsKey);
	soap_default_int(soap, &a->fileCode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getMarks(struct soap *soap, const struct swad__getMarks *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getMarks(struct soap *soap, const char *tag, int id, const struct swad__getMarks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getMarks), type))
		return soap->error;
	if (soap_out_string(soap, "wsKey", -1, &a->wsKey, ""))
		return soap->error;
	if (soap_out_int(soap, "fileCode", -1, &a->fileCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getMarks * SOAP_FMAC4 soap_in_swad__getMarks(struct soap *soap, const char *tag, struct swad__getMarks *a, const char *type)
{
	size_t soap_flag_wsKey = 1;
	size_t soap_flag_fileCode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getMarks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getMarks, sizeof(struct swad__getMarks), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getMarks(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsKey", &a->wsKey, "xsd:string"))
				{	soap_flag_wsKey--;
					continue;
				}
			if (soap_flag_fileCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "fileCode", &a->fileCode, "xsd:int"))
				{	soap_flag_fileCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getMarks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getMarks, 0, sizeof(struct swad__getMarks), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fileCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getMarks(struct soap *soap, const struct swad__getMarks *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getMarks);
	if (soap_out_swad__getMarks(soap, tag?tag:"swad:getMarks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getMarks * SOAP_FMAC4 soap_get_swad__getMarks(struct soap *soap, struct swad__getMarks *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getMarks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getFile(struct soap *soap, struct swad__getFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsKey);
	soap_default_int(soap, &a->fileCode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getFile(struct soap *soap, const struct swad__getFile *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getFile(struct soap *soap, const char *tag, int id, const struct swad__getFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getFile), type))
		return soap->error;
	if (soap_out_string(soap, "wsKey", -1, &a->wsKey, ""))
		return soap->error;
	if (soap_out_int(soap, "fileCode", -1, &a->fileCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getFile * SOAP_FMAC4 soap_in_swad__getFile(struct soap *soap, const char *tag, struct swad__getFile *a, const char *type)
{
	size_t soap_flag_wsKey = 1;
	size_t soap_flag_fileCode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getFile, sizeof(struct swad__getFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getFile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsKey", &a->wsKey, "xsd:string"))
				{	soap_flag_wsKey--;
					continue;
				}
			if (soap_flag_fileCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "fileCode", &a->fileCode, "xsd:int"))
				{	soap_flag_fileCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getFile, 0, sizeof(struct swad__getFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fileCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getFile(struct soap *soap, const struct swad__getFile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getFile);
	if (soap_out_swad__getFile(soap, tag?tag:"swad:getFile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getFile * SOAP_FMAC4 soap_get_swad__getFile(struct soap *soap, struct swad__getFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getDirectoryTree(struct soap *soap, struct swad__getDirectoryTree *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsKey);
	soap_default_int(soap, &a->courseCode);
	soap_default_int(soap, &a->groupCode);
	soap_default_int(soap, &a->treeCode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getDirectoryTree(struct soap *soap, const struct swad__getDirectoryTree *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getDirectoryTree(struct soap *soap, const char *tag, int id, const struct swad__getDirectoryTree *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getDirectoryTree), type))
		return soap->error;
	if (soap_out_string(soap, "wsKey", -1, &a->wsKey, ""))
		return soap->error;
	if (soap_out_int(soap, "courseCode", -1, &a->courseCode, ""))
		return soap->error;
	if (soap_out_int(soap, "groupCode", -1, &a->groupCode, ""))
		return soap->error;
	if (soap_out_int(soap, "treeCode", -1, &a->treeCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getDirectoryTree * SOAP_FMAC4 soap_in_swad__getDirectoryTree(struct soap *soap, const char *tag, struct swad__getDirectoryTree *a, const char *type)
{
	size_t soap_flag_wsKey = 1;
	size_t soap_flag_courseCode = 1;
	size_t soap_flag_groupCode = 1;
	size_t soap_flag_treeCode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getDirectoryTree *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getDirectoryTree, sizeof(struct swad__getDirectoryTree), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getDirectoryTree(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsKey", &a->wsKey, "xsd:string"))
				{	soap_flag_wsKey--;
					continue;
				}
			if (soap_flag_courseCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "courseCode", &a->courseCode, "xsd:int"))
				{	soap_flag_courseCode--;
					continue;
				}
			if (soap_flag_groupCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "groupCode", &a->groupCode, "xsd:int"))
				{	soap_flag_groupCode--;
					continue;
				}
			if (soap_flag_treeCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "treeCode", &a->treeCode, "xsd:int"))
				{	soap_flag_treeCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getDirectoryTree *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getDirectoryTree, 0, sizeof(struct swad__getDirectoryTree), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_courseCode > 0 || soap_flag_groupCode > 0 || soap_flag_treeCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getDirectoryTree(struct soap *soap, const struct swad__getDirectoryTree *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getDirectoryTree);
	if (soap_out_swad__getDirectoryTree(soap, tag?tag:"swad:getDirectoryTree", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getDirectoryTree * SOAP_FMAC4 soap_get_swad__getDirectoryTree(struct soap *soap, struct swad__getDirectoryTree *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getDirectoryTree(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__sendMyGroups(struct soap *soap, struct swad__sendMyGroups *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsKey);
	soap_default_int(soap, &a->courseCode);
	soap_default_string(soap, &a->myGroups);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__sendMyGroups(struct soap *soap, const struct swad__sendMyGroups *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsKey);
	soap_serialize_string(soap, &a->myGroups);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__sendMyGroups(struct soap *soap, const char *tag, int id, const struct swad__sendMyGroups *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__sendMyGroups), type))
		return soap->error;
	if (soap_out_string(soap, "wsKey", -1, &a->wsKey, ""))
		return soap->error;
	if (soap_out_int(soap, "courseCode", -1, &a->courseCode, ""))
		return soap->error;
	if (soap_out_string(soap, "myGroups", -1, &a->myGroups, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__sendMyGroups * SOAP_FMAC4 soap_in_swad__sendMyGroups(struct soap *soap, const char *tag, struct swad__sendMyGroups *a, const char *type)
{
	size_t soap_flag_wsKey = 1;
	size_t soap_flag_courseCode = 1;
	size_t soap_flag_myGroups = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__sendMyGroups *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__sendMyGroups, sizeof(struct swad__sendMyGroups), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__sendMyGroups(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsKey", &a->wsKey, "xsd:string"))
				{	soap_flag_wsKey--;
					continue;
				}
			if (soap_flag_courseCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "courseCode", &a->courseCode, "xsd:int"))
				{	soap_flag_courseCode--;
					continue;
				}
			if (soap_flag_myGroups && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "myGroups", &a->myGroups, "xsd:string"))
				{	soap_flag_myGroups--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__sendMyGroups *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__sendMyGroups, 0, sizeof(struct swad__sendMyGroups), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_courseCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__sendMyGroups(struct soap *soap, const struct swad__sendMyGroups *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__sendMyGroups);
	if (soap_out_swad__sendMyGroups(soap, tag?tag:"swad:sendMyGroups", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__sendMyGroups * SOAP_FMAC4 soap_get_swad__sendMyGroups(struct soap *soap, struct swad__sendMyGroups *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__sendMyGroups(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getGroups(struct soap *soap, struct swad__getGroups *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsKey);
	soap_default_int(soap, &a->courseCode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getGroups(struct soap *soap, const struct swad__getGroups *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getGroups(struct soap *soap, const char *tag, int id, const struct swad__getGroups *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getGroups), type))
		return soap->error;
	if (soap_out_string(soap, "wsKey", -1, &a->wsKey, ""))
		return soap->error;
	if (soap_out_int(soap, "courseCode", -1, &a->courseCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getGroups * SOAP_FMAC4 soap_in_swad__getGroups(struct soap *soap, const char *tag, struct swad__getGroups *a, const char *type)
{
	size_t soap_flag_wsKey = 1;
	size_t soap_flag_courseCode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getGroups *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getGroups, sizeof(struct swad__getGroups), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getGroups(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsKey", &a->wsKey, "xsd:string"))
				{	soap_flag_wsKey--;
					continue;
				}
			if (soap_flag_courseCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "courseCode", &a->courseCode, "xsd:int"))
				{	soap_flag_courseCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getGroups *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getGroups, 0, sizeof(struct swad__getGroups), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_courseCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getGroups(struct soap *soap, const struct swad__getGroups *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getGroups);
	if (soap_out_swad__getGroups(soap, tag?tag:"swad:getGroups", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getGroups * SOAP_FMAC4 soap_get_swad__getGroups(struct soap *soap, struct swad__getGroups *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getGroups(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getGroupTypes(struct soap *soap, struct swad__getGroupTypes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsKey);
	soap_default_int(soap, &a->courseCode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getGroupTypes(struct soap *soap, const struct swad__getGroupTypes *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getGroupTypes(struct soap *soap, const char *tag, int id, const struct swad__getGroupTypes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getGroupTypes), type))
		return soap->error;
	if (soap_out_string(soap, "wsKey", -1, &a->wsKey, ""))
		return soap->error;
	if (soap_out_int(soap, "courseCode", -1, &a->courseCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getGroupTypes * SOAP_FMAC4 soap_in_swad__getGroupTypes(struct soap *soap, const char *tag, struct swad__getGroupTypes *a, const char *type)
{
	size_t soap_flag_wsKey = 1;
	size_t soap_flag_courseCode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getGroupTypes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getGroupTypes, sizeof(struct swad__getGroupTypes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getGroupTypes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsKey", &a->wsKey, "xsd:string"))
				{	soap_flag_wsKey--;
					continue;
				}
			if (soap_flag_courseCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "courseCode", &a->courseCode, "xsd:int"))
				{	soap_flag_courseCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getGroupTypes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getGroupTypes, 0, sizeof(struct swad__getGroupTypes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_courseCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getGroupTypes(struct soap *soap, const struct swad__getGroupTypes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getGroupTypes);
	if (soap_out_swad__getGroupTypes(soap, tag?tag:"swad:getGroupTypes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getGroupTypes * SOAP_FMAC4 soap_get_swad__getGroupTypes(struct soap *soap, struct swad__getGroupTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getGroupTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getCourseInfo(struct soap *soap, struct swad__getCourseInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsKey);
	soap_default_int(soap, &a->courseCode);
	soap_default_string(soap, &a->infoType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getCourseInfo(struct soap *soap, const struct swad__getCourseInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsKey);
	soap_serialize_string(soap, &a->infoType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getCourseInfo(struct soap *soap, const char *tag, int id, const struct swad__getCourseInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getCourseInfo), type))
		return soap->error;
	if (soap_out_string(soap, "wsKey", -1, &a->wsKey, ""))
		return soap->error;
	if (soap_out_int(soap, "courseCode", -1, &a->courseCode, ""))
		return soap->error;
	if (soap_out_string(soap, "infoType", -1, &a->infoType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getCourseInfo * SOAP_FMAC4 soap_in_swad__getCourseInfo(struct soap *soap, const char *tag, struct swad__getCourseInfo *a, const char *type)
{
	size_t soap_flag_wsKey = 1;
	size_t soap_flag_courseCode = 1;
	size_t soap_flag_infoType = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getCourseInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getCourseInfo, sizeof(struct swad__getCourseInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getCourseInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsKey", &a->wsKey, "xsd:string"))
				{	soap_flag_wsKey--;
					continue;
				}
			if (soap_flag_courseCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "courseCode", &a->courseCode, "xsd:int"))
				{	soap_flag_courseCode--;
					continue;
				}
			if (soap_flag_infoType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "infoType", &a->infoType, "xsd:string"))
				{	soap_flag_infoType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getCourseInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getCourseInfo, 0, sizeof(struct swad__getCourseInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_courseCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getCourseInfo(struct soap *soap, const struct swad__getCourseInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getCourseInfo);
	if (soap_out_swad__getCourseInfo(soap, tag?tag:"swad:getCourseInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getCourseInfo * SOAP_FMAC4 soap_get_swad__getCourseInfo(struct soap *soap, struct swad__getCourseInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getCourseInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getCourses(struct soap *soap, struct swad__getCourses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsKey);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getCourses(struct soap *soap, const struct swad__getCourses *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getCourses(struct soap *soap, const char *tag, int id, const struct swad__getCourses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getCourses), type))
		return soap->error;
	if (soap_out_string(soap, "wsKey", -1, &a->wsKey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getCourses * SOAP_FMAC4 soap_in_swad__getCourses(struct soap *soap, const char *tag, struct swad__getCourses *a, const char *type)
{
	size_t soap_flag_wsKey = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getCourses *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getCourses, sizeof(struct swad__getCourses), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getCourses(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsKey", &a->wsKey, "xsd:string"))
				{	soap_flag_wsKey--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getCourses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getCourses, 0, sizeof(struct swad__getCourses), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getCourses(struct soap *soap, const struct swad__getCourses *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getCourses);
	if (soap_out_swad__getCourses(soap, tag?tag:"swad:getCourses", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getCourses * SOAP_FMAC4 soap_get_swad__getCourses(struct soap *soap, struct swad__getCourses *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getCourses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getNewPassword(struct soap *soap, struct swad__getNewPassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->userID);
	soap_default_string(soap, &a->appKey);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getNewPassword(struct soap *soap, const struct swad__getNewPassword *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->userID);
	soap_serialize_string(soap, &a->appKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getNewPassword(struct soap *soap, const char *tag, int id, const struct swad__getNewPassword *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getNewPassword), type))
		return soap->error;
	if (soap_out_string(soap, "userID", -1, &a->userID, ""))
		return soap->error;
	if (soap_out_string(soap, "appKey", -1, &a->appKey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getNewPassword * SOAP_FMAC4 soap_in_swad__getNewPassword(struct soap *soap, const char *tag, struct swad__getNewPassword *a, const char *type)
{
	size_t soap_flag_userID = 1;
	size_t soap_flag_appKey = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getNewPassword *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getNewPassword, sizeof(struct swad__getNewPassword), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getNewPassword(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userID", &a->userID, "xsd:string"))
				{	soap_flag_userID--;
					continue;
				}
			if (soap_flag_appKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "appKey", &a->appKey, "xsd:string"))
				{	soap_flag_appKey--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getNewPassword *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getNewPassword, 0, sizeof(struct swad__getNewPassword), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getNewPassword(struct soap *soap, const struct swad__getNewPassword *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getNewPassword);
	if (soap_out_swad__getNewPassword(soap, tag?tag:"swad:getNewPassword", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getNewPassword * SOAP_FMAC4 soap_get_swad__getNewPassword(struct soap *soap, struct swad__getNewPassword *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getNewPassword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__loginBySessionKey(struct soap *soap, struct swad__loginBySessionKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->sessionID);
	soap_default_string(soap, &a->appKey);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__loginBySessionKey(struct soap *soap, const struct swad__loginBySessionKey *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->sessionID);
	soap_serialize_string(soap, &a->appKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__loginBySessionKey(struct soap *soap, const char *tag, int id, const struct swad__loginBySessionKey *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__loginBySessionKey), type))
		return soap->error;
	if (soap_out_string(soap, "sessionID", -1, &a->sessionID, ""))
		return soap->error;
	if (soap_out_string(soap, "appKey", -1, &a->appKey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__loginBySessionKey * SOAP_FMAC4 soap_in_swad__loginBySessionKey(struct soap *soap, const char *tag, struct swad__loginBySessionKey *a, const char *type)
{
	size_t soap_flag_sessionID = 1;
	size_t soap_flag_appKey = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__loginBySessionKey *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__loginBySessionKey, sizeof(struct swad__loginBySessionKey), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__loginBySessionKey(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sessionID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sessionID", &a->sessionID, "xsd:string"))
				{	soap_flag_sessionID--;
					continue;
				}
			if (soap_flag_appKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "appKey", &a->appKey, "xsd:string"))
				{	soap_flag_appKey--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__loginBySessionKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__loginBySessionKey, 0, sizeof(struct swad__loginBySessionKey), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__loginBySessionKey(struct soap *soap, const struct swad__loginBySessionKey *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__loginBySessionKey);
	if (soap_out_swad__loginBySessionKey(soap, tag?tag:"swad:loginBySessionKey", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__loginBySessionKey * SOAP_FMAC4 soap_get_swad__loginBySessionKey(struct soap *soap, struct swad__loginBySessionKey *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__loginBySessionKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__loginByUserPasswordKey(struct soap *soap, struct swad__loginByUserPasswordKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->userID);
	soap_default_string(soap, &a->userPassword);
	soap_default_string(soap, &a->appKey);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__loginByUserPasswordKey(struct soap *soap, const struct swad__loginByUserPasswordKey *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->userID);
	soap_serialize_string(soap, &a->userPassword);
	soap_serialize_string(soap, &a->appKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__loginByUserPasswordKey(struct soap *soap, const char *tag, int id, const struct swad__loginByUserPasswordKey *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__loginByUserPasswordKey), type))
		return soap->error;
	if (soap_out_string(soap, "userID", -1, &a->userID, ""))
		return soap->error;
	if (soap_out_string(soap, "userPassword", -1, &a->userPassword, ""))
		return soap->error;
	if (soap_out_string(soap, "appKey", -1, &a->appKey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__loginByUserPasswordKey * SOAP_FMAC4 soap_in_swad__loginByUserPasswordKey(struct soap *soap, const char *tag, struct swad__loginByUserPasswordKey *a, const char *type)
{
	size_t soap_flag_userID = 1;
	size_t soap_flag_userPassword = 1;
	size_t soap_flag_appKey = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__loginByUserPasswordKey *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__loginByUserPasswordKey, sizeof(struct swad__loginByUserPasswordKey), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__loginByUserPasswordKey(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userID", &a->userID, "xsd:string"))
				{	soap_flag_userID--;
					continue;
				}
			if (soap_flag_userPassword && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userPassword", &a->userPassword, "xsd:string"))
				{	soap_flag_userPassword--;
					continue;
				}
			if (soap_flag_appKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "appKey", &a->appKey, "xsd:string"))
				{	soap_flag_appKey--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__loginByUserPasswordKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__loginByUserPasswordKey, 0, sizeof(struct swad__loginByUserPasswordKey), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__loginByUserPasswordKey(struct soap *soap, const struct swad__loginByUserPasswordKey *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__loginByUserPasswordKey);
	if (soap_out_swad__loginByUserPasswordKey(soap, tag?tag:"swad:loginByUserPasswordKey", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__loginByUserPasswordKey * SOAP_FMAC4 soap_get_swad__loginByUserPasswordKey(struct soap *soap, struct swad__loginByUserPasswordKey *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__loginByUserPasswordKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__createAccount(struct soap *soap, struct swad__createAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->userNickname);
	soap_default_string(soap, &a->userEmail);
	soap_default_string(soap, &a->userID);
	soap_default_string(soap, &a->userPassword);
	soap_default_string(soap, &a->appKey);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__createAccount(struct soap *soap, const struct swad__createAccount *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->userNickname);
	soap_serialize_string(soap, &a->userEmail);
	soap_serialize_string(soap, &a->userID);
	soap_serialize_string(soap, &a->userPassword);
	soap_serialize_string(soap, &a->appKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__createAccount(struct soap *soap, const char *tag, int id, const struct swad__createAccount *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__createAccount), type))
		return soap->error;
	if (soap_out_string(soap, "userNickname", -1, &a->userNickname, ""))
		return soap->error;
	if (soap_out_string(soap, "userEmail", -1, &a->userEmail, ""))
		return soap->error;
	if (soap_out_string(soap, "userID", -1, &a->userID, ""))
		return soap->error;
	if (soap_out_string(soap, "userPassword", -1, &a->userPassword, ""))
		return soap->error;
	if (soap_out_string(soap, "appKey", -1, &a->appKey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__createAccount * SOAP_FMAC4 soap_in_swad__createAccount(struct soap *soap, const char *tag, struct swad__createAccount *a, const char *type)
{
	size_t soap_flag_userNickname = 1;
	size_t soap_flag_userEmail = 1;
	size_t soap_flag_userID = 1;
	size_t soap_flag_userPassword = 1;
	size_t soap_flag_appKey = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__createAccount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__createAccount, sizeof(struct swad__createAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__createAccount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userNickname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userNickname", &a->userNickname, "xsd:string"))
				{	soap_flag_userNickname--;
					continue;
				}
			if (soap_flag_userEmail && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userEmail", &a->userEmail, "xsd:string"))
				{	soap_flag_userEmail--;
					continue;
				}
			if (soap_flag_userID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userID", &a->userID, "xsd:string"))
				{	soap_flag_userID--;
					continue;
				}
			if (soap_flag_userPassword && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userPassword", &a->userPassword, "xsd:string"))
				{	soap_flag_userPassword--;
					continue;
				}
			if (soap_flag_appKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "appKey", &a->appKey, "xsd:string"))
				{	soap_flag_appKey--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__createAccount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__createAccount, 0, sizeof(struct swad__createAccount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__createAccount(struct soap *soap, const struct swad__createAccount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__createAccount);
	if (soap_out_swad__createAccount(soap, tag?tag:"swad:createAccount", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__createAccount * SOAP_FMAC4 soap_get_swad__createAccount(struct soap *soap, struct swad__createAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__createAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__sendMessageOutput(struct soap *soap, struct swad__sendMessageOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->numUsers);
	soap_default_swad__usersArray(soap, &a->usersArray);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__sendMessageOutput(struct soap *soap, const struct swad__sendMessageOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_swad__usersArray(soap, &a->usersArray);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__sendMessageOutput(struct soap *soap, const char *tag, int id, const struct swad__sendMessageOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__sendMessageOutput), type))
		return soap->error;
	if (soap_out_int(soap, "numUsers", -1, &a->numUsers, ""))
		return soap->error;
	if (soap_out_swad__usersArray(soap, "usersArray", -1, &a->usersArray, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__sendMessageOutput * SOAP_FMAC4 soap_in_swad__sendMessageOutput(struct soap *soap, const char *tag, struct swad__sendMessageOutput *a, const char *type)
{
	size_t soap_flag_numUsers = 1;
	size_t soap_flag_usersArray = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__sendMessageOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__sendMessageOutput, sizeof(struct swad__sendMessageOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__sendMessageOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_numUsers && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numUsers", &a->numUsers, "xsd:int"))
				{	soap_flag_numUsers--;
					continue;
				}
			if (soap_flag_usersArray && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_swad__usersArray(soap, "usersArray", &a->usersArray, "swad:usersArray"))
				{	soap_flag_usersArray--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__sendMessageOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__sendMessageOutput, 0, sizeof(struct swad__sendMessageOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_numUsers > 0 || soap_flag_usersArray > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__sendMessageOutput(struct soap *soap, const struct swad__sendMessageOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__sendMessageOutput);
	if (soap_out_swad__sendMessageOutput(soap, tag?tag:"swad:sendMessageOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__sendMessageOutput * SOAP_FMAC4 soap_get_swad__sendMessageOutput(struct soap *soap, struct swad__sendMessageOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__sendMessageOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__sendNoticeOutput(struct soap *soap, struct swad__sendNoticeOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->noticeCode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__sendNoticeOutput(struct soap *soap, const struct swad__sendNoticeOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__sendNoticeOutput(struct soap *soap, const char *tag, int id, const struct swad__sendNoticeOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__sendNoticeOutput), type))
		return soap->error;
	if (soap_out_int(soap, "noticeCode", -1, &a->noticeCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__sendNoticeOutput * SOAP_FMAC4 soap_in_swad__sendNoticeOutput(struct soap *soap, const char *tag, struct swad__sendNoticeOutput *a, const char *type)
{
	size_t soap_flag_noticeCode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__sendNoticeOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__sendNoticeOutput, sizeof(struct swad__sendNoticeOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__sendNoticeOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_noticeCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "noticeCode", &a->noticeCode, "xsd:int"))
				{	soap_flag_noticeCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__sendNoticeOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__sendNoticeOutput, 0, sizeof(struct swad__sendNoticeOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_noticeCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__sendNoticeOutput(struct soap *soap, const struct swad__sendNoticeOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__sendNoticeOutput);
	if (soap_out_swad__sendNoticeOutput(soap, tag?tag:"swad:sendNoticeOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__sendNoticeOutput * SOAP_FMAC4 soap_get_swad__sendNoticeOutput(struct soap *soap, struct swad__sendNoticeOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__sendNoticeOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getMarksOutput(struct soap *soap, struct swad__getMarksOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->content);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getMarksOutput(struct soap *soap, const struct swad__getMarksOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->content);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getMarksOutput(struct soap *soap, const char *tag, int id, const struct swad__getMarksOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getMarksOutput), type))
		return soap->error;
	if (soap_out_string(soap, "content", -1, &a->content, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getMarksOutput * SOAP_FMAC4 soap_in_swad__getMarksOutput(struct soap *soap, const char *tag, struct swad__getMarksOutput *a, const char *type)
{
	size_t soap_flag_content = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getMarksOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getMarksOutput, sizeof(struct swad__getMarksOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getMarksOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_content && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "content", &a->content, "xsd:string"))
				{	soap_flag_content--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getMarksOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getMarksOutput, 0, sizeof(struct swad__getMarksOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getMarksOutput(struct soap *soap, const struct swad__getMarksOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getMarksOutput);
	if (soap_out_swad__getMarksOutput(soap, tag?tag:"swad:getMarksOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getMarksOutput * SOAP_FMAC4 soap_get_swad__getMarksOutput(struct soap *soap, struct swad__getMarksOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getMarksOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getFileOutput(struct soap *soap, struct swad__getFileOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->fileName);
	soap_default_string(soap, &a->URL);
	soap_default_int(soap, &a->size);
	soap_default_int(soap, &a->time);
	soap_default_string(soap, &a->license);
	soap_default_string(soap, &a->publisherName);
	soap_default_string(soap, &a->publisherPhoto);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getFileOutput(struct soap *soap, const struct swad__getFileOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->fileName);
	soap_serialize_string(soap, &a->URL);
	soap_serialize_string(soap, &a->license);
	soap_serialize_string(soap, &a->publisherName);
	soap_serialize_string(soap, &a->publisherPhoto);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getFileOutput(struct soap *soap, const char *tag, int id, const struct swad__getFileOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getFileOutput), type))
		return soap->error;
	if (soap_out_string(soap, "fileName", -1, &a->fileName, ""))
		return soap->error;
	if (soap_out_string(soap, "URL", -1, &a->URL, ""))
		return soap->error;
	if (soap_out_int(soap, "size", -1, &a->size, ""))
		return soap->error;
	if (soap_out_int(soap, "time", -1, &a->time, ""))
		return soap->error;
	if (soap_out_string(soap, "license", -1, &a->license, ""))
		return soap->error;
	if (soap_out_string(soap, "publisherName", -1, &a->publisherName, ""))
		return soap->error;
	if (soap_out_string(soap, "publisherPhoto", -1, &a->publisherPhoto, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getFileOutput * SOAP_FMAC4 soap_in_swad__getFileOutput(struct soap *soap, const char *tag, struct swad__getFileOutput *a, const char *type)
{
	size_t soap_flag_fileName = 1;
	size_t soap_flag_URL = 1;
	size_t soap_flag_size = 1;
	size_t soap_flag_time = 1;
	size_t soap_flag_license = 1;
	size_t soap_flag_publisherName = 1;
	size_t soap_flag_publisherPhoto = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getFileOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getFileOutput, sizeof(struct swad__getFileOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getFileOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fileName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fileName", &a->fileName, "xsd:string"))
				{	soap_flag_fileName--;
					continue;
				}
			if (soap_flag_URL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "URL", &a->URL, "xsd:string"))
				{	soap_flag_URL--;
					continue;
				}
			if (soap_flag_size && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "size", &a->size, "xsd:int"))
				{	soap_flag_size--;
					continue;
				}
			if (soap_flag_time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "time", &a->time, "xsd:int"))
				{	soap_flag_time--;
					continue;
				}
			if (soap_flag_license && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "license", &a->license, "xsd:string"))
				{	soap_flag_license--;
					continue;
				}
			if (soap_flag_publisherName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "publisherName", &a->publisherName, "xsd:string"))
				{	soap_flag_publisherName--;
					continue;
				}
			if (soap_flag_publisherPhoto && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "publisherPhoto", &a->publisherPhoto, "xsd:string"))
				{	soap_flag_publisherPhoto--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getFileOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getFileOutput, 0, sizeof(struct swad__getFileOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_size > 0 || soap_flag_time > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getFileOutput(struct soap *soap, const struct swad__getFileOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getFileOutput);
	if (soap_out_swad__getFileOutput(soap, tag?tag:"swad:getFileOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getFileOutput * SOAP_FMAC4 soap_get_swad__getFileOutput(struct soap *soap, struct swad__getFileOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getFileOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getDirectoryTreeOutput(struct soap *soap, struct swad__getDirectoryTreeOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->tree);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getDirectoryTreeOutput(struct soap *soap, const struct swad__getDirectoryTreeOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->tree);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getDirectoryTreeOutput(struct soap *soap, const char *tag, int id, const struct swad__getDirectoryTreeOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getDirectoryTreeOutput), type))
		return soap->error;
	if (soap_out_string(soap, "tree", -1, &a->tree, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getDirectoryTreeOutput * SOAP_FMAC4 soap_in_swad__getDirectoryTreeOutput(struct soap *soap, const char *tag, struct swad__getDirectoryTreeOutput *a, const char *type)
{
	size_t soap_flag_tree = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getDirectoryTreeOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getDirectoryTreeOutput, sizeof(struct swad__getDirectoryTreeOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getDirectoryTreeOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tree && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tree", &a->tree, "xsd:string"))
				{	soap_flag_tree--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getDirectoryTreeOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getDirectoryTreeOutput, 0, sizeof(struct swad__getDirectoryTreeOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getDirectoryTreeOutput(struct soap *soap, const struct swad__getDirectoryTreeOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getDirectoryTreeOutput);
	if (soap_out_swad__getDirectoryTreeOutput(soap, tag?tag:"swad:getDirectoryTreeOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getDirectoryTreeOutput * SOAP_FMAC4 soap_get_swad__getDirectoryTreeOutput(struct soap *soap, struct swad__getDirectoryTreeOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getDirectoryTreeOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__sendAttendanceUsersOutput(struct soap *soap, struct swad__sendAttendanceUsersOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->success);
	soap_default_int(soap, &a->numUsers);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__sendAttendanceUsersOutput(struct soap *soap, const struct swad__sendAttendanceUsersOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__sendAttendanceUsersOutput(struct soap *soap, const char *tag, int id, const struct swad__sendAttendanceUsersOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__sendAttendanceUsersOutput), type))
		return soap->error;
	if (soap_out_int(soap, "success", -1, &a->success, ""))
		return soap->error;
	if (soap_out_int(soap, "numUsers", -1, &a->numUsers, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__sendAttendanceUsersOutput * SOAP_FMAC4 soap_in_swad__sendAttendanceUsersOutput(struct soap *soap, const char *tag, struct swad__sendAttendanceUsersOutput *a, const char *type)
{
	size_t soap_flag_success = 1;
	size_t soap_flag_numUsers = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__sendAttendanceUsersOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__sendAttendanceUsersOutput, sizeof(struct swad__sendAttendanceUsersOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__sendAttendanceUsersOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_success && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "success", &a->success, "xsd:int"))
				{	soap_flag_success--;
					continue;
				}
			if (soap_flag_numUsers && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numUsers", &a->numUsers, "xsd:int"))
				{	soap_flag_numUsers--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__sendAttendanceUsersOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__sendAttendanceUsersOutput, 0, sizeof(struct swad__sendAttendanceUsersOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_success > 0 || soap_flag_numUsers > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__sendAttendanceUsersOutput(struct soap *soap, const struct swad__sendAttendanceUsersOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__sendAttendanceUsersOutput);
	if (soap_out_swad__sendAttendanceUsersOutput(soap, tag?tag:"swad:sendAttendanceUsersOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__sendAttendanceUsersOutput * SOAP_FMAC4 soap_get_swad__sendAttendanceUsersOutput(struct soap *soap, struct swad__sendAttendanceUsersOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__sendAttendanceUsersOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getAttendanceUsersOutput(struct soap *soap, struct swad__getAttendanceUsersOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->numUsers);
	soap_default_swad__attendanceUsersArray(soap, &a->usersArray);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getAttendanceUsersOutput(struct soap *soap, const struct swad__getAttendanceUsersOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_swad__attendanceUsersArray(soap, &a->usersArray);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getAttendanceUsersOutput(struct soap *soap, const char *tag, int id, const struct swad__getAttendanceUsersOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getAttendanceUsersOutput), type))
		return soap->error;
	if (soap_out_int(soap, "numUsers", -1, &a->numUsers, ""))
		return soap->error;
	if (soap_out_swad__attendanceUsersArray(soap, "usersArray", -1, &a->usersArray, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getAttendanceUsersOutput * SOAP_FMAC4 soap_in_swad__getAttendanceUsersOutput(struct soap *soap, const char *tag, struct swad__getAttendanceUsersOutput *a, const char *type)
{
	size_t soap_flag_numUsers = 1;
	size_t soap_flag_usersArray = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getAttendanceUsersOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getAttendanceUsersOutput, sizeof(struct swad__getAttendanceUsersOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getAttendanceUsersOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_numUsers && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numUsers", &a->numUsers, "xsd:int"))
				{	soap_flag_numUsers--;
					continue;
				}
			if (soap_flag_usersArray && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_swad__attendanceUsersArray(soap, "usersArray", &a->usersArray, "swad:attendanceUsersArray"))
				{	soap_flag_usersArray--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getAttendanceUsersOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getAttendanceUsersOutput, 0, sizeof(struct swad__getAttendanceUsersOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_numUsers > 0 || soap_flag_usersArray > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getAttendanceUsersOutput(struct soap *soap, const struct swad__getAttendanceUsersOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getAttendanceUsersOutput);
	if (soap_out_swad__getAttendanceUsersOutput(soap, tag?tag:"swad:getAttendanceUsersOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getAttendanceUsersOutput * SOAP_FMAC4 soap_get_swad__getAttendanceUsersOutput(struct soap *soap, struct swad__getAttendanceUsersOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getAttendanceUsersOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__attendanceUsersArray(struct soap *soap, struct swad__attendanceUsersArray *a)
{	(void)soap;
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__attendanceUsersArray(struct soap *soap, struct swad__attendanceUsersArray const*a)
{
#ifndef WITH_NOIDREF
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)(void*)&a->__ptr, 1, SOAP_TYPE_swad__attendanceUsersArray))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_swad__attendanceUser);
			soap_serialize_swad__attendanceUser(soap, a->__ptr + i);
		}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__attendanceUsersArray(struct soap *soap, const char *tag, int id, const struct swad__attendanceUsersArray *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)(void*)&a->__ptr, 1, type, SOAP_TYPE_swad__attendanceUsersArray);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_swad__attendanceUser(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__attendanceUsersArray * SOAP_FMAC4 soap_in_swad__attendanceUsersArray(struct soap *soap, const char *tag, struct swad__attendanceUsersArray *a, const char *type)
{	int i, j;
	struct swad__attendanceUser *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "swad:attendanceUser") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct swad__attendanceUsersArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__attendanceUsersArray, sizeof(struct swad__attendanceUsersArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__attendanceUsersArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct swad__attendanceUser *)soap_malloc(soap, sizeof(struct swad__attendanceUser) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_swad__attendanceUser(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_swad__attendanceUser(soap, NULL, a->__ptr + i, "swad:attendanceUser"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct swad__attendanceUser *)soap_push_block(soap, NULL, sizeof(struct swad__attendanceUser));
				if (!p)
					return NULL;
				soap_default_swad__attendanceUser(soap, p);
				if (!soap_in_swad__attendanceUser(soap, NULL, p, "swad:attendanceUser"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct swad__attendanceUser *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__attendanceUsersArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__attendanceUsersArray, 0, sizeof(struct swad__attendanceUsersArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__attendanceUsersArray(struct soap *soap, const struct swad__attendanceUsersArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)(void*)&a->__ptr, 1, tag, SOAP_TYPE_swad__attendanceUsersArray);
	if (soap_out_swad__attendanceUsersArray(soap, tag?tag:"swad:attendanceUsersArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__attendanceUsersArray * SOAP_FMAC4 soap_get_swad__attendanceUsersArray(struct soap *soap, struct swad__attendanceUsersArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__attendanceUsersArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__attendanceUser(struct soap *soap, struct swad__attendanceUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->userCode);
	soap_default_string(soap, &a->userNickname);
	soap_default_string(soap, &a->userID);
	soap_default_string(soap, &a->userSurname1);
	soap_default_string(soap, &a->userSurname2);
	soap_default_string(soap, &a->userFirstname);
	soap_default_string(soap, &a->userPhoto);
	soap_default_int(soap, &a->present);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__attendanceUser(struct soap *soap, const struct swad__attendanceUser *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->userNickname);
	soap_serialize_string(soap, &a->userID);
	soap_serialize_string(soap, &a->userSurname1);
	soap_serialize_string(soap, &a->userSurname2);
	soap_serialize_string(soap, &a->userFirstname);
	soap_serialize_string(soap, &a->userPhoto);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__attendanceUser(struct soap *soap, const char *tag, int id, const struct swad__attendanceUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__attendanceUser), type))
		return soap->error;
	if (soap_out_int(soap, "userCode", -1, &a->userCode, ""))
		return soap->error;
	if (soap_out_string(soap, "userNickname", -1, &a->userNickname, ""))
		return soap->error;
	if (soap_out_string(soap, "userID", -1, &a->userID, ""))
		return soap->error;
	if (soap_out_string(soap, "userSurname1", -1, &a->userSurname1, ""))
		return soap->error;
	if (soap_out_string(soap, "userSurname2", -1, &a->userSurname2, ""))
		return soap->error;
	if (soap_out_string(soap, "userFirstname", -1, &a->userFirstname, ""))
		return soap->error;
	if (soap_out_string(soap, "userPhoto", -1, &a->userPhoto, ""))
		return soap->error;
	if (soap_out_int(soap, "present", -1, &a->present, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__attendanceUser * SOAP_FMAC4 soap_in_swad__attendanceUser(struct soap *soap, const char *tag, struct swad__attendanceUser *a, const char *type)
{
	size_t soap_flag_userCode = 1;
	size_t soap_flag_userNickname = 1;
	size_t soap_flag_userID = 1;
	size_t soap_flag_userSurname1 = 1;
	size_t soap_flag_userSurname2 = 1;
	size_t soap_flag_userFirstname = 1;
	size_t soap_flag_userPhoto = 1;
	size_t soap_flag_present = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__attendanceUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__attendanceUser, sizeof(struct swad__attendanceUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__attendanceUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "userCode", &a->userCode, "xsd:int"))
				{	soap_flag_userCode--;
					continue;
				}
			if (soap_flag_userNickname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userNickname", &a->userNickname, "xsd:string"))
				{	soap_flag_userNickname--;
					continue;
				}
			if (soap_flag_userID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userID", &a->userID, "xsd:string"))
				{	soap_flag_userID--;
					continue;
				}
			if (soap_flag_userSurname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userSurname1", &a->userSurname1, "xsd:string"))
				{	soap_flag_userSurname1--;
					continue;
				}
			if (soap_flag_userSurname2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userSurname2", &a->userSurname2, "xsd:string"))
				{	soap_flag_userSurname2--;
					continue;
				}
			if (soap_flag_userFirstname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userFirstname", &a->userFirstname, "xsd:string"))
				{	soap_flag_userFirstname--;
					continue;
				}
			if (soap_flag_userPhoto && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userPhoto", &a->userPhoto, "xsd:string"))
				{	soap_flag_userPhoto--;
					continue;
				}
			if (soap_flag_present && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "present", &a->present, "xsd:int"))
				{	soap_flag_present--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__attendanceUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__attendanceUser, 0, sizeof(struct swad__attendanceUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userCode > 0 || soap_flag_present > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__attendanceUser(struct soap *soap, const struct swad__attendanceUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__attendanceUser);
	if (soap_out_swad__attendanceUser(soap, tag?tag:"swad:attendanceUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__attendanceUser * SOAP_FMAC4 soap_get_swad__attendanceUser(struct soap *soap, struct swad__attendanceUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__attendanceUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__sendAttendanceEventOutput(struct soap *soap, struct swad__sendAttendanceEventOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->attendanceEventCode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__sendAttendanceEventOutput(struct soap *soap, const struct swad__sendAttendanceEventOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__sendAttendanceEventOutput(struct soap *soap, const char *tag, int id, const struct swad__sendAttendanceEventOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__sendAttendanceEventOutput), type))
		return soap->error;
	if (soap_out_int(soap, "attendanceEventCode", -1, &a->attendanceEventCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__sendAttendanceEventOutput * SOAP_FMAC4 soap_in_swad__sendAttendanceEventOutput(struct soap *soap, const char *tag, struct swad__sendAttendanceEventOutput *a, const char *type)
{
	size_t soap_flag_attendanceEventCode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__sendAttendanceEventOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__sendAttendanceEventOutput, sizeof(struct swad__sendAttendanceEventOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__sendAttendanceEventOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_attendanceEventCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "attendanceEventCode", &a->attendanceEventCode, "xsd:int"))
				{	soap_flag_attendanceEventCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__sendAttendanceEventOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__sendAttendanceEventOutput, 0, sizeof(struct swad__sendAttendanceEventOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_attendanceEventCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__sendAttendanceEventOutput(struct soap *soap, const struct swad__sendAttendanceEventOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__sendAttendanceEventOutput);
	if (soap_out_swad__sendAttendanceEventOutput(soap, tag?tag:"swad:sendAttendanceEventOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__sendAttendanceEventOutput * SOAP_FMAC4 soap_get_swad__sendAttendanceEventOutput(struct soap *soap, struct swad__sendAttendanceEventOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__sendAttendanceEventOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getAttendanceEventsOutput(struct soap *soap, struct swad__getAttendanceEventsOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->numEvents);
	soap_default_swad__attendanceEventsArray(soap, &a->eventsArray);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getAttendanceEventsOutput(struct soap *soap, const struct swad__getAttendanceEventsOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_swad__attendanceEventsArray(soap, &a->eventsArray);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getAttendanceEventsOutput(struct soap *soap, const char *tag, int id, const struct swad__getAttendanceEventsOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getAttendanceEventsOutput), type))
		return soap->error;
	if (soap_out_int(soap, "numEvents", -1, &a->numEvents, ""))
		return soap->error;
	if (soap_out_swad__attendanceEventsArray(soap, "eventsArray", -1, &a->eventsArray, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getAttendanceEventsOutput * SOAP_FMAC4 soap_in_swad__getAttendanceEventsOutput(struct soap *soap, const char *tag, struct swad__getAttendanceEventsOutput *a, const char *type)
{
	size_t soap_flag_numEvents = 1;
	size_t soap_flag_eventsArray = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getAttendanceEventsOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getAttendanceEventsOutput, sizeof(struct swad__getAttendanceEventsOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getAttendanceEventsOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_numEvents && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numEvents", &a->numEvents, "xsd:int"))
				{	soap_flag_numEvents--;
					continue;
				}
			if (soap_flag_eventsArray && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_swad__attendanceEventsArray(soap, "eventsArray", &a->eventsArray, "swad:attendanceEventsArray"))
				{	soap_flag_eventsArray--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getAttendanceEventsOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getAttendanceEventsOutput, 0, sizeof(struct swad__getAttendanceEventsOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_numEvents > 0 || soap_flag_eventsArray > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getAttendanceEventsOutput(struct soap *soap, const struct swad__getAttendanceEventsOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getAttendanceEventsOutput);
	if (soap_out_swad__getAttendanceEventsOutput(soap, tag?tag:"swad:getAttendanceEventsOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getAttendanceEventsOutput * SOAP_FMAC4 soap_get_swad__getAttendanceEventsOutput(struct soap *soap, struct swad__getAttendanceEventsOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getAttendanceEventsOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__attendanceEventsArray(struct soap *soap, struct swad__attendanceEventsArray *a)
{	(void)soap;
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__attendanceEventsArray(struct soap *soap, struct swad__attendanceEventsArray const*a)
{
#ifndef WITH_NOIDREF
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)(void*)&a->__ptr, 1, SOAP_TYPE_swad__attendanceEventsArray))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_swad__attendanceEvent);
			soap_serialize_swad__attendanceEvent(soap, a->__ptr + i);
		}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__attendanceEventsArray(struct soap *soap, const char *tag, int id, const struct swad__attendanceEventsArray *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)(void*)&a->__ptr, 1, type, SOAP_TYPE_swad__attendanceEventsArray);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_swad__attendanceEvent(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__attendanceEventsArray * SOAP_FMAC4 soap_in_swad__attendanceEventsArray(struct soap *soap, const char *tag, struct swad__attendanceEventsArray *a, const char *type)
{	int i, j;
	struct swad__attendanceEvent *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "swad:attendanceEvent") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct swad__attendanceEventsArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__attendanceEventsArray, sizeof(struct swad__attendanceEventsArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__attendanceEventsArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct swad__attendanceEvent *)soap_malloc(soap, sizeof(struct swad__attendanceEvent) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_swad__attendanceEvent(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_swad__attendanceEvent(soap, NULL, a->__ptr + i, "swad:attendanceEvent"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct swad__attendanceEvent *)soap_push_block(soap, NULL, sizeof(struct swad__attendanceEvent));
				if (!p)
					return NULL;
				soap_default_swad__attendanceEvent(soap, p);
				if (!soap_in_swad__attendanceEvent(soap, NULL, p, "swad:attendanceEvent"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct swad__attendanceEvent *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__attendanceEventsArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__attendanceEventsArray, 0, sizeof(struct swad__attendanceEventsArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__attendanceEventsArray(struct soap *soap, const struct swad__attendanceEventsArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)(void*)&a->__ptr, 1, tag, SOAP_TYPE_swad__attendanceEventsArray);
	if (soap_out_swad__attendanceEventsArray(soap, tag?tag:"swad:attendanceEventsArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__attendanceEventsArray * SOAP_FMAC4 soap_get_swad__attendanceEventsArray(struct soap *soap, struct swad__attendanceEventsArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__attendanceEventsArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__attendanceEvent(struct soap *soap, struct swad__attendanceEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->attendanceEventCode);
	soap_default_int(soap, &a->hidden);
	soap_default_string(soap, &a->userSurname1);
	soap_default_string(soap, &a->userSurname2);
	soap_default_string(soap, &a->userFirstname);
	soap_default_string(soap, &a->userPhoto);
	soap_default_int(soap, &a->startTime);
	soap_default_int(soap, &a->endTime);
	soap_default_int(soap, &a->commentsTeachersVisible);
	soap_default_string(soap, &a->title);
	soap_default_string(soap, &a->text);
	soap_default_string(soap, &a->groups);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__attendanceEvent(struct soap *soap, const struct swad__attendanceEvent *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->userSurname1);
	soap_serialize_string(soap, &a->userSurname2);
	soap_serialize_string(soap, &a->userFirstname);
	soap_serialize_string(soap, &a->userPhoto);
	soap_serialize_string(soap, &a->title);
	soap_serialize_string(soap, &a->text);
	soap_serialize_string(soap, &a->groups);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__attendanceEvent(struct soap *soap, const char *tag, int id, const struct swad__attendanceEvent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__attendanceEvent), type))
		return soap->error;
	if (soap_out_int(soap, "attendanceEventCode", -1, &a->attendanceEventCode, ""))
		return soap->error;
	if (soap_out_int(soap, "hidden", -1, &a->hidden, ""))
		return soap->error;
	if (soap_out_string(soap, "userSurname1", -1, &a->userSurname1, ""))
		return soap->error;
	if (soap_out_string(soap, "userSurname2", -1, &a->userSurname2, ""))
		return soap->error;
	if (soap_out_string(soap, "userFirstname", -1, &a->userFirstname, ""))
		return soap->error;
	if (soap_out_string(soap, "userPhoto", -1, &a->userPhoto, ""))
		return soap->error;
	if (soap_out_int(soap, "startTime", -1, &a->startTime, ""))
		return soap->error;
	if (soap_out_int(soap, "endTime", -1, &a->endTime, ""))
		return soap->error;
	if (soap_out_int(soap, "commentsTeachersVisible", -1, &a->commentsTeachersVisible, ""))
		return soap->error;
	if (soap_out_string(soap, "title", -1, &a->title, ""))
		return soap->error;
	if (soap_out_string(soap, "text", -1, &a->text, ""))
		return soap->error;
	if (soap_out_string(soap, "groups", -1, &a->groups, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__attendanceEvent * SOAP_FMAC4 soap_in_swad__attendanceEvent(struct soap *soap, const char *tag, struct swad__attendanceEvent *a, const char *type)
{
	size_t soap_flag_attendanceEventCode = 1;
	size_t soap_flag_hidden = 1;
	size_t soap_flag_userSurname1 = 1;
	size_t soap_flag_userSurname2 = 1;
	size_t soap_flag_userFirstname = 1;
	size_t soap_flag_userPhoto = 1;
	size_t soap_flag_startTime = 1;
	size_t soap_flag_endTime = 1;
	size_t soap_flag_commentsTeachersVisible = 1;
	size_t soap_flag_title = 1;
	size_t soap_flag_text = 1;
	size_t soap_flag_groups = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__attendanceEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__attendanceEvent, sizeof(struct swad__attendanceEvent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__attendanceEvent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_attendanceEventCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "attendanceEventCode", &a->attendanceEventCode, "xsd:int"))
				{	soap_flag_attendanceEventCode--;
					continue;
				}
			if (soap_flag_hidden && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "hidden", &a->hidden, "xsd:int"))
				{	soap_flag_hidden--;
					continue;
				}
			if (soap_flag_userSurname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userSurname1", &a->userSurname1, "xsd:string"))
				{	soap_flag_userSurname1--;
					continue;
				}
			if (soap_flag_userSurname2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userSurname2", &a->userSurname2, "xsd:string"))
				{	soap_flag_userSurname2--;
					continue;
				}
			if (soap_flag_userFirstname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userFirstname", &a->userFirstname, "xsd:string"))
				{	soap_flag_userFirstname--;
					continue;
				}
			if (soap_flag_userPhoto && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userPhoto", &a->userPhoto, "xsd:string"))
				{	soap_flag_userPhoto--;
					continue;
				}
			if (soap_flag_startTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "startTime", &a->startTime, "xsd:int"))
				{	soap_flag_startTime--;
					continue;
				}
			if (soap_flag_endTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "endTime", &a->endTime, "xsd:int"))
				{	soap_flag_endTime--;
					continue;
				}
			if (soap_flag_commentsTeachersVisible && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "commentsTeachersVisible", &a->commentsTeachersVisible, "xsd:int"))
				{	soap_flag_commentsTeachersVisible--;
					continue;
				}
			if (soap_flag_title && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "title", &a->title, "xsd:string"))
				{	soap_flag_title--;
					continue;
				}
			if (soap_flag_text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "text", &a->text, "xsd:string"))
				{	soap_flag_text--;
					continue;
				}
			if (soap_flag_groups && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "groups", &a->groups, "xsd:string"))
				{	soap_flag_groups--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__attendanceEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__attendanceEvent, 0, sizeof(struct swad__attendanceEvent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_attendanceEventCode > 0 || soap_flag_hidden > 0 || soap_flag_startTime > 0 || soap_flag_endTime > 0 || soap_flag_commentsTeachersVisible > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__attendanceEvent(struct soap *soap, const struct swad__attendanceEvent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__attendanceEvent);
	if (soap_out_swad__attendanceEvent(soap, tag?tag:"swad:attendanceEvent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__attendanceEvent * SOAP_FMAC4 soap_get_swad__attendanceEvent(struct soap *soap, struct swad__attendanceEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__attendanceEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getUsersOutput(struct soap *soap, struct swad__getUsersOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->numUsers);
	soap_default_swad__usersArray(soap, &a->usersArray);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getUsersOutput(struct soap *soap, const struct swad__getUsersOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_swad__usersArray(soap, &a->usersArray);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getUsersOutput(struct soap *soap, const char *tag, int id, const struct swad__getUsersOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getUsersOutput), type))
		return soap->error;
	if (soap_out_int(soap, "numUsers", -1, &a->numUsers, ""))
		return soap->error;
	if (soap_out_swad__usersArray(soap, "usersArray", -1, &a->usersArray, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getUsersOutput * SOAP_FMAC4 soap_in_swad__getUsersOutput(struct soap *soap, const char *tag, struct swad__getUsersOutput *a, const char *type)
{
	size_t soap_flag_numUsers = 1;
	size_t soap_flag_usersArray = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getUsersOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getUsersOutput, sizeof(struct swad__getUsersOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getUsersOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_numUsers && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numUsers", &a->numUsers, "xsd:int"))
				{	soap_flag_numUsers--;
					continue;
				}
			if (soap_flag_usersArray && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_swad__usersArray(soap, "usersArray", &a->usersArray, "swad:usersArray"))
				{	soap_flag_usersArray--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getUsersOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getUsersOutput, 0, sizeof(struct swad__getUsersOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_numUsers > 0 || soap_flag_usersArray > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getUsersOutput(struct soap *soap, const struct swad__getUsersOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getUsersOutput);
	if (soap_out_swad__getUsersOutput(soap, tag?tag:"swad:getUsersOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getUsersOutput * SOAP_FMAC4 soap_get_swad__getUsersOutput(struct soap *soap, struct swad__getUsersOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getUsersOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__usersArray(struct soap *soap, struct swad__usersArray *a)
{	(void)soap;
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__usersArray(struct soap *soap, struct swad__usersArray const*a)
{
#ifndef WITH_NOIDREF
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)(void*)&a->__ptr, 1, SOAP_TYPE_swad__usersArray))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_swad__user);
			soap_serialize_swad__user(soap, a->__ptr + i);
		}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__usersArray(struct soap *soap, const char *tag, int id, const struct swad__usersArray *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)(void*)&a->__ptr, 1, type, SOAP_TYPE_swad__usersArray);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_swad__user(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__usersArray * SOAP_FMAC4 soap_in_swad__usersArray(struct soap *soap, const char *tag, struct swad__usersArray *a, const char *type)
{	int i, j;
	struct swad__user *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "swad:user") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct swad__usersArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__usersArray, sizeof(struct swad__usersArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__usersArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct swad__user *)soap_malloc(soap, sizeof(struct swad__user) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_swad__user(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_swad__user(soap, NULL, a->__ptr + i, "swad:user"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct swad__user *)soap_push_block(soap, NULL, sizeof(struct swad__user));
				if (!p)
					return NULL;
				soap_default_swad__user(soap, p);
				if (!soap_in_swad__user(soap, NULL, p, "swad:user"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct swad__user *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__usersArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__usersArray, 0, sizeof(struct swad__usersArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__usersArray(struct soap *soap, const struct swad__usersArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)(void*)&a->__ptr, 1, tag, SOAP_TYPE_swad__usersArray);
	if (soap_out_swad__usersArray(soap, tag?tag:"swad:usersArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__usersArray * SOAP_FMAC4 soap_get_swad__usersArray(struct soap *soap, struct swad__usersArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__usersArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__user(struct soap *soap, struct swad__user *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->userCode);
	soap_default_string(soap, &a->userNickname);
	soap_default_string(soap, &a->userID);
	soap_default_string(soap, &a->userSurname1);
	soap_default_string(soap, &a->userSurname2);
	soap_default_string(soap, &a->userFirstname);
	soap_default_string(soap, &a->userPhoto);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__user(struct soap *soap, const struct swad__user *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->userNickname);
	soap_serialize_string(soap, &a->userID);
	soap_serialize_string(soap, &a->userSurname1);
	soap_serialize_string(soap, &a->userSurname2);
	soap_serialize_string(soap, &a->userFirstname);
	soap_serialize_string(soap, &a->userPhoto);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__user(struct soap *soap, const char *tag, int id, const struct swad__user *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__user), type))
		return soap->error;
	if (soap_out_int(soap, "userCode", -1, &a->userCode, ""))
		return soap->error;
	if (soap_out_string(soap, "userNickname", -1, &a->userNickname, ""))
		return soap->error;
	if (soap_out_string(soap, "userID", -1, &a->userID, ""))
		return soap->error;
	if (soap_out_string(soap, "userSurname1", -1, &a->userSurname1, ""))
		return soap->error;
	if (soap_out_string(soap, "userSurname2", -1, &a->userSurname2, ""))
		return soap->error;
	if (soap_out_string(soap, "userFirstname", -1, &a->userFirstname, ""))
		return soap->error;
	if (soap_out_string(soap, "userPhoto", -1, &a->userPhoto, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__user * SOAP_FMAC4 soap_in_swad__user(struct soap *soap, const char *tag, struct swad__user *a, const char *type)
{
	size_t soap_flag_userCode = 1;
	size_t soap_flag_userNickname = 1;
	size_t soap_flag_userID = 1;
	size_t soap_flag_userSurname1 = 1;
	size_t soap_flag_userSurname2 = 1;
	size_t soap_flag_userFirstname = 1;
	size_t soap_flag_userPhoto = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__user *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__user, sizeof(struct swad__user), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__user(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "userCode", &a->userCode, "xsd:int"))
				{	soap_flag_userCode--;
					continue;
				}
			if (soap_flag_userNickname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userNickname", &a->userNickname, "xsd:string"))
				{	soap_flag_userNickname--;
					continue;
				}
			if (soap_flag_userID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userID", &a->userID, "xsd:string"))
				{	soap_flag_userID--;
					continue;
				}
			if (soap_flag_userSurname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userSurname1", &a->userSurname1, "xsd:string"))
				{	soap_flag_userSurname1--;
					continue;
				}
			if (soap_flag_userSurname2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userSurname2", &a->userSurname2, "xsd:string"))
				{	soap_flag_userSurname2--;
					continue;
				}
			if (soap_flag_userFirstname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userFirstname", &a->userFirstname, "xsd:string"))
				{	soap_flag_userFirstname--;
					continue;
				}
			if (soap_flag_userPhoto && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userPhoto", &a->userPhoto, "xsd:string"))
				{	soap_flag_userPhoto--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__user *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__user, 0, sizeof(struct swad__user), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__user(struct soap *soap, const struct swad__user *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__user);
	if (soap_out_swad__user(soap, tag?tag:"swad:user", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__user * SOAP_FMAC4 soap_get_swad__user(struct soap *soap, struct swad__user *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__user(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getTestsOutput(struct soap *soap, struct swad__getTestsOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_swad__tagsArray(soap, &a->tagsArray);
	soap_default_swad__questionsArray(soap, &a->questionsArray);
	soap_default_swad__answersArray(soap, &a->answersArray);
	soap_default_swad__questionTagsArray(soap, &a->questionTagsArray);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getTestsOutput(struct soap *soap, const struct swad__getTestsOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_swad__tagsArray(soap, &a->tagsArray);
	soap_serialize_swad__questionsArray(soap, &a->questionsArray);
	soap_serialize_swad__answersArray(soap, &a->answersArray);
	soap_serialize_swad__questionTagsArray(soap, &a->questionTagsArray);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getTestsOutput(struct soap *soap, const char *tag, int id, const struct swad__getTestsOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getTestsOutput), type))
		return soap->error;
	if (soap_out_swad__tagsArray(soap, "tagsArray", -1, &a->tagsArray, ""))
		return soap->error;
	if (soap_out_swad__questionsArray(soap, "questionsArray", -1, &a->questionsArray, ""))
		return soap->error;
	if (soap_out_swad__answersArray(soap, "answersArray", -1, &a->answersArray, ""))
		return soap->error;
	if (soap_out_swad__questionTagsArray(soap, "questionTagsArray", -1, &a->questionTagsArray, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getTestsOutput * SOAP_FMAC4 soap_in_swad__getTestsOutput(struct soap *soap, const char *tag, struct swad__getTestsOutput *a, const char *type)
{
	size_t soap_flag_tagsArray = 1;
	size_t soap_flag_questionsArray = 1;
	size_t soap_flag_answersArray = 1;
	size_t soap_flag_questionTagsArray = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getTestsOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getTestsOutput, sizeof(struct swad__getTestsOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getTestsOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tagsArray && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_swad__tagsArray(soap, "tagsArray", &a->tagsArray, "swad:tagsArray"))
				{	soap_flag_tagsArray--;
					continue;
				}
			if (soap_flag_questionsArray && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_swad__questionsArray(soap, "questionsArray", &a->questionsArray, "swad:questionsArray"))
				{	soap_flag_questionsArray--;
					continue;
				}
			if (soap_flag_answersArray && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_swad__answersArray(soap, "answersArray", &a->answersArray, "swad:answersArray"))
				{	soap_flag_answersArray--;
					continue;
				}
			if (soap_flag_questionTagsArray && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_swad__questionTagsArray(soap, "questionTagsArray", &a->questionTagsArray, "swad:questionTagsArray"))
				{	soap_flag_questionTagsArray--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getTestsOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getTestsOutput, 0, sizeof(struct swad__getTestsOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tagsArray > 0 || soap_flag_questionsArray > 0 || soap_flag_answersArray > 0 || soap_flag_questionTagsArray > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getTestsOutput(struct soap *soap, const struct swad__getTestsOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getTestsOutput);
	if (soap_out_swad__getTestsOutput(soap, tag?tag:"swad:getTestsOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getTestsOutput * SOAP_FMAC4 soap_get_swad__getTestsOutput(struct soap *soap, struct swad__getTestsOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getTestsOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__questionTagsArray(struct soap *soap, struct swad__questionTagsArray *a)
{	(void)soap;
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__questionTagsArray(struct soap *soap, struct swad__questionTagsArray const*a)
{
#ifndef WITH_NOIDREF
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)(void*)&a->__ptr, 1, SOAP_TYPE_swad__questionTagsArray))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_swad__questionTag);
			soap_serialize_swad__questionTag(soap, a->__ptr + i);
		}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__questionTagsArray(struct soap *soap, const char *tag, int id, const struct swad__questionTagsArray *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)(void*)&a->__ptr, 1, type, SOAP_TYPE_swad__questionTagsArray);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_swad__questionTag(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__questionTagsArray * SOAP_FMAC4 soap_in_swad__questionTagsArray(struct soap *soap, const char *tag, struct swad__questionTagsArray *a, const char *type)
{	int i, j;
	struct swad__questionTag *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "swad:questionTag") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct swad__questionTagsArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__questionTagsArray, sizeof(struct swad__questionTagsArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__questionTagsArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct swad__questionTag *)soap_malloc(soap, sizeof(struct swad__questionTag) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_swad__questionTag(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_swad__questionTag(soap, NULL, a->__ptr + i, "swad:questionTag"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct swad__questionTag *)soap_push_block(soap, NULL, sizeof(struct swad__questionTag));
				if (!p)
					return NULL;
				soap_default_swad__questionTag(soap, p);
				if (!soap_in_swad__questionTag(soap, NULL, p, "swad:questionTag"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct swad__questionTag *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__questionTagsArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__questionTagsArray, 0, sizeof(struct swad__questionTagsArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__questionTagsArray(struct soap *soap, const struct swad__questionTagsArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)(void*)&a->__ptr, 1, tag, SOAP_TYPE_swad__questionTagsArray);
	if (soap_out_swad__questionTagsArray(soap, tag?tag:"swad:questionTagsArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__questionTagsArray * SOAP_FMAC4 soap_get_swad__questionTagsArray(struct soap *soap, struct swad__questionTagsArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__questionTagsArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__questionTag(struct soap *soap, struct swad__questionTag *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->questionCode);
	soap_default_int(soap, &a->tagCode);
	soap_default_int(soap, &a->tagIndex);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__questionTag(struct soap *soap, const struct swad__questionTag *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__questionTag(struct soap *soap, const char *tag, int id, const struct swad__questionTag *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__questionTag), type))
		return soap->error;
	if (soap_out_int(soap, "questionCode", -1, &a->questionCode, ""))
		return soap->error;
	if (soap_out_int(soap, "tagCode", -1, &a->tagCode, ""))
		return soap->error;
	if (soap_out_int(soap, "tagIndex", -1, &a->tagIndex, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__questionTag * SOAP_FMAC4 soap_in_swad__questionTag(struct soap *soap, const char *tag, struct swad__questionTag *a, const char *type)
{
	size_t soap_flag_questionCode = 1;
	size_t soap_flag_tagCode = 1;
	size_t soap_flag_tagIndex = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__questionTag *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__questionTag, sizeof(struct swad__questionTag), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__questionTag(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_questionCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "questionCode", &a->questionCode, "xsd:int"))
				{	soap_flag_questionCode--;
					continue;
				}
			if (soap_flag_tagCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tagCode", &a->tagCode, "xsd:int"))
				{	soap_flag_tagCode--;
					continue;
				}
			if (soap_flag_tagIndex && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tagIndex", &a->tagIndex, "xsd:int"))
				{	soap_flag_tagIndex--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__questionTag *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__questionTag, 0, sizeof(struct swad__questionTag), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_questionCode > 0 || soap_flag_tagCode > 0 || soap_flag_tagIndex > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__questionTag(struct soap *soap, const struct swad__questionTag *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__questionTag);
	if (soap_out_swad__questionTag(soap, tag?tag:"swad:questionTag", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__questionTag * SOAP_FMAC4 soap_get_swad__questionTag(struct soap *soap, struct swad__questionTag *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__questionTag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__answersArray(struct soap *soap, struct swad__answersArray *a)
{	(void)soap;
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__answersArray(struct soap *soap, struct swad__answersArray const*a)
{
#ifndef WITH_NOIDREF
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)(void*)&a->__ptr, 1, SOAP_TYPE_swad__answersArray))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_swad__answer);
			soap_serialize_swad__answer(soap, a->__ptr + i);
		}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__answersArray(struct soap *soap, const char *tag, int id, const struct swad__answersArray *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)(void*)&a->__ptr, 1, type, SOAP_TYPE_swad__answersArray);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_swad__answer(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__answersArray * SOAP_FMAC4 soap_in_swad__answersArray(struct soap *soap, const char *tag, struct swad__answersArray *a, const char *type)
{	int i, j;
	struct swad__answer *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "swad:answer") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct swad__answersArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__answersArray, sizeof(struct swad__answersArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__answersArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct swad__answer *)soap_malloc(soap, sizeof(struct swad__answer) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_swad__answer(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_swad__answer(soap, NULL, a->__ptr + i, "swad:answer"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct swad__answer *)soap_push_block(soap, NULL, sizeof(struct swad__answer));
				if (!p)
					return NULL;
				soap_default_swad__answer(soap, p);
				if (!soap_in_swad__answer(soap, NULL, p, "swad:answer"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct swad__answer *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__answersArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__answersArray, 0, sizeof(struct swad__answersArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__answersArray(struct soap *soap, const struct swad__answersArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)(void*)&a->__ptr, 1, tag, SOAP_TYPE_swad__answersArray);
	if (soap_out_swad__answersArray(soap, tag?tag:"swad:answersArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__answersArray * SOAP_FMAC4 soap_get_swad__answersArray(struct soap *soap, struct swad__answersArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__answersArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__answer(struct soap *soap, struct swad__answer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->questionCode);
	soap_default_int(soap, &a->answerIndex);
	soap_default_int(soap, &a->correct);
	soap_default_string(soap, &a->answerText);
	soap_default_string(soap, &a->answerFeedback);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__answer(struct soap *soap, const struct swad__answer *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->answerText);
	soap_serialize_string(soap, &a->answerFeedback);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__answer(struct soap *soap, const char *tag, int id, const struct swad__answer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__answer), type))
		return soap->error;
	if (soap_out_int(soap, "questionCode", -1, &a->questionCode, ""))
		return soap->error;
	if (soap_out_int(soap, "answerIndex", -1, &a->answerIndex, ""))
		return soap->error;
	if (soap_out_int(soap, "correct", -1, &a->correct, ""))
		return soap->error;
	if (soap_out_string(soap, "answerText", -1, &a->answerText, ""))
		return soap->error;
	if (soap_out_string(soap, "answerFeedback", -1, &a->answerFeedback, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__answer * SOAP_FMAC4 soap_in_swad__answer(struct soap *soap, const char *tag, struct swad__answer *a, const char *type)
{
	size_t soap_flag_questionCode = 1;
	size_t soap_flag_answerIndex = 1;
	size_t soap_flag_correct = 1;
	size_t soap_flag_answerText = 1;
	size_t soap_flag_answerFeedback = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__answer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__answer, sizeof(struct swad__answer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__answer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_questionCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "questionCode", &a->questionCode, "xsd:int"))
				{	soap_flag_questionCode--;
					continue;
				}
			if (soap_flag_answerIndex && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "answerIndex", &a->answerIndex, "xsd:int"))
				{	soap_flag_answerIndex--;
					continue;
				}
			if (soap_flag_correct && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "correct", &a->correct, "xsd:int"))
				{	soap_flag_correct--;
					continue;
				}
			if (soap_flag_answerText && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "answerText", &a->answerText, "xsd:string"))
				{	soap_flag_answerText--;
					continue;
				}
			if (soap_flag_answerFeedback && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "answerFeedback", &a->answerFeedback, "xsd:string"))
				{	soap_flag_answerFeedback--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__answer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__answer, 0, sizeof(struct swad__answer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_questionCode > 0 || soap_flag_answerIndex > 0 || soap_flag_correct > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__answer(struct soap *soap, const struct swad__answer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__answer);
	if (soap_out_swad__answer(soap, tag?tag:"swad:answer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__answer * SOAP_FMAC4 soap_get_swad__answer(struct soap *soap, struct swad__answer *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__answer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__questionsArray(struct soap *soap, struct swad__questionsArray *a)
{	(void)soap;
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__questionsArray(struct soap *soap, struct swad__questionsArray const*a)
{
#ifndef WITH_NOIDREF
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)(void*)&a->__ptr, 1, SOAP_TYPE_swad__questionsArray))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_swad__question);
			soap_serialize_swad__question(soap, a->__ptr + i);
		}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__questionsArray(struct soap *soap, const char *tag, int id, const struct swad__questionsArray *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)(void*)&a->__ptr, 1, type, SOAP_TYPE_swad__questionsArray);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_swad__question(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__questionsArray * SOAP_FMAC4 soap_in_swad__questionsArray(struct soap *soap, const char *tag, struct swad__questionsArray *a, const char *type)
{	int i, j;
	struct swad__question *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "swad:question") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct swad__questionsArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__questionsArray, sizeof(struct swad__questionsArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__questionsArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct swad__question *)soap_malloc(soap, sizeof(struct swad__question) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_swad__question(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_swad__question(soap, NULL, a->__ptr + i, "swad:question"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct swad__question *)soap_push_block(soap, NULL, sizeof(struct swad__question));
				if (!p)
					return NULL;
				soap_default_swad__question(soap, p);
				if (!soap_in_swad__question(soap, NULL, p, "swad:question"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct swad__question *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__questionsArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__questionsArray, 0, sizeof(struct swad__questionsArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__questionsArray(struct soap *soap, const struct swad__questionsArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)(void*)&a->__ptr, 1, tag, SOAP_TYPE_swad__questionsArray);
	if (soap_out_swad__questionsArray(soap, tag?tag:"swad:questionsArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__questionsArray * SOAP_FMAC4 soap_get_swad__questionsArray(struct soap *soap, struct swad__questionsArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__questionsArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__question(struct soap *soap, struct swad__question *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->questionCode);
	soap_default_string(soap, &a->answerType);
	soap_default_int(soap, &a->shuffle);
	soap_default_string(soap, &a->stem);
	soap_default_string(soap, &a->feedback);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__question(struct soap *soap, const struct swad__question *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->answerType);
	soap_serialize_string(soap, &a->stem);
	soap_serialize_string(soap, &a->feedback);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__question(struct soap *soap, const char *tag, int id, const struct swad__question *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__question), type))
		return soap->error;
	if (soap_out_int(soap, "questionCode", -1, &a->questionCode, ""))
		return soap->error;
	if (soap_out_string(soap, "answerType", -1, &a->answerType, ""))
		return soap->error;
	if (soap_out_int(soap, "shuffle", -1, &a->shuffle, ""))
		return soap->error;
	if (soap_out_string(soap, "stem", -1, &a->stem, ""))
		return soap->error;
	if (soap_out_string(soap, "feedback", -1, &a->feedback, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__question * SOAP_FMAC4 soap_in_swad__question(struct soap *soap, const char *tag, struct swad__question *a, const char *type)
{
	size_t soap_flag_questionCode = 1;
	size_t soap_flag_answerType = 1;
	size_t soap_flag_shuffle = 1;
	size_t soap_flag_stem = 1;
	size_t soap_flag_feedback = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__question *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__question, sizeof(struct swad__question), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__question(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_questionCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "questionCode", &a->questionCode, "xsd:int"))
				{	soap_flag_questionCode--;
					continue;
				}
			if (soap_flag_answerType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "answerType", &a->answerType, "xsd:string"))
				{	soap_flag_answerType--;
					continue;
				}
			if (soap_flag_shuffle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "shuffle", &a->shuffle, "xsd:int"))
				{	soap_flag_shuffle--;
					continue;
				}
			if (soap_flag_stem && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "stem", &a->stem, "xsd:string"))
				{	soap_flag_stem--;
					continue;
				}
			if (soap_flag_feedback && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "feedback", &a->feedback, "xsd:string"))
				{	soap_flag_feedback--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__question *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__question, 0, sizeof(struct swad__question), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_questionCode > 0 || soap_flag_shuffle > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__question(struct soap *soap, const struct swad__question *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__question);
	if (soap_out_swad__question(soap, tag?tag:"swad:question", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__question * SOAP_FMAC4 soap_get_swad__question(struct soap *soap, struct swad__question *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__question(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__tagsArray(struct soap *soap, struct swad__tagsArray *a)
{	(void)soap;
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__tagsArray(struct soap *soap, struct swad__tagsArray const*a)
{
#ifndef WITH_NOIDREF
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)(void*)&a->__ptr, 1, SOAP_TYPE_swad__tagsArray))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_swad__tag);
			soap_serialize_swad__tag(soap, a->__ptr + i);
		}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__tagsArray(struct soap *soap, const char *tag, int id, const struct swad__tagsArray *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)(void*)&a->__ptr, 1, type, SOAP_TYPE_swad__tagsArray);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_swad__tag(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__tagsArray * SOAP_FMAC4 soap_in_swad__tagsArray(struct soap *soap, const char *tag, struct swad__tagsArray *a, const char *type)
{	int i, j;
	struct swad__tag *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "swad:tag") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct swad__tagsArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__tagsArray, sizeof(struct swad__tagsArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__tagsArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct swad__tag *)soap_malloc(soap, sizeof(struct swad__tag) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_swad__tag(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_swad__tag(soap, NULL, a->__ptr + i, "swad:tag"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct swad__tag *)soap_push_block(soap, NULL, sizeof(struct swad__tag));
				if (!p)
					return NULL;
				soap_default_swad__tag(soap, p);
				if (!soap_in_swad__tag(soap, NULL, p, "swad:tag"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct swad__tag *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__tagsArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__tagsArray, 0, sizeof(struct swad__tagsArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__tagsArray(struct soap *soap, const struct swad__tagsArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)(void*)&a->__ptr, 1, tag, SOAP_TYPE_swad__tagsArray);
	if (soap_out_swad__tagsArray(soap, tag?tag:"swad:tagsArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__tagsArray * SOAP_FMAC4 soap_get_swad__tagsArray(struct soap *soap, struct swad__tagsArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__tagsArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__tag(struct soap *soap, struct swad__tag *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->tagCode);
	soap_default_string(soap, &a->tagText);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__tag(struct soap *soap, const struct swad__tag *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->tagText);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__tag(struct soap *soap, const char *tag, int id, const struct swad__tag *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__tag), type))
		return soap->error;
	if (soap_out_int(soap, "tagCode", -1, &a->tagCode, ""))
		return soap->error;
	if (soap_out_string(soap, "tagText", -1, &a->tagText, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__tag * SOAP_FMAC4 soap_in_swad__tag(struct soap *soap, const char *tag, struct swad__tag *a, const char *type)
{
	size_t soap_flag_tagCode = 1;
	size_t soap_flag_tagText = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__tag *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__tag, sizeof(struct swad__tag), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__tag(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tagCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tagCode", &a->tagCode, "xsd:int"))
				{	soap_flag_tagCode--;
					continue;
				}
			if (soap_flag_tagText && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tagText", &a->tagText, "xsd:string"))
				{	soap_flag_tagText--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__tag *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__tag, 0, sizeof(struct swad__tag), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tagCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__tag(struct soap *soap, const struct swad__tag *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__tag);
	if (soap_out_swad__tag(soap, tag?tag:"swad:tag", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__tag * SOAP_FMAC4 soap_get_swad__tag(struct soap *soap, struct swad__tag *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__tag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getTestConfigOutput(struct soap *soap, struct swad__getTestConfigOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->pluggable);
	soap_default_int(soap, &a->numQuestions);
	soap_default_int(soap, &a->minQuestions);
	soap_default_int(soap, &a->defQuestions);
	soap_default_int(soap, &a->maxQuestions);
	soap_default_string(soap, &a->feedback);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getTestConfigOutput(struct soap *soap, const struct swad__getTestConfigOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->feedback);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getTestConfigOutput(struct soap *soap, const char *tag, int id, const struct swad__getTestConfigOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getTestConfigOutput), type))
		return soap->error;
	if (soap_out_int(soap, "pluggable", -1, &a->pluggable, ""))
		return soap->error;
	if (soap_out_int(soap, "numQuestions", -1, &a->numQuestions, ""))
		return soap->error;
	if (soap_out_int(soap, "minQuestions", -1, &a->minQuestions, ""))
		return soap->error;
	if (soap_out_int(soap, "defQuestions", -1, &a->defQuestions, ""))
		return soap->error;
	if (soap_out_int(soap, "maxQuestions", -1, &a->maxQuestions, ""))
		return soap->error;
	if (soap_out_string(soap, "feedback", -1, &a->feedback, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getTestConfigOutput * SOAP_FMAC4 soap_in_swad__getTestConfigOutput(struct soap *soap, const char *tag, struct swad__getTestConfigOutput *a, const char *type)
{
	size_t soap_flag_pluggable = 1;
	size_t soap_flag_numQuestions = 1;
	size_t soap_flag_minQuestions = 1;
	size_t soap_flag_defQuestions = 1;
	size_t soap_flag_maxQuestions = 1;
	size_t soap_flag_feedback = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getTestConfigOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getTestConfigOutput, sizeof(struct swad__getTestConfigOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getTestConfigOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pluggable && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "pluggable", &a->pluggable, "xsd:int"))
				{	soap_flag_pluggable--;
					continue;
				}
			if (soap_flag_numQuestions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numQuestions", &a->numQuestions, "xsd:int"))
				{	soap_flag_numQuestions--;
					continue;
				}
			if (soap_flag_minQuestions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "minQuestions", &a->minQuestions, "xsd:int"))
				{	soap_flag_minQuestions--;
					continue;
				}
			if (soap_flag_defQuestions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "defQuestions", &a->defQuestions, "xsd:int"))
				{	soap_flag_defQuestions--;
					continue;
				}
			if (soap_flag_maxQuestions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "maxQuestions", &a->maxQuestions, "xsd:int"))
				{	soap_flag_maxQuestions--;
					continue;
				}
			if (soap_flag_feedback && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "feedback", &a->feedback, "xsd:string"))
				{	soap_flag_feedback--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getTestConfigOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getTestConfigOutput, 0, sizeof(struct swad__getTestConfigOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pluggable > 0 || soap_flag_numQuestions > 0 || soap_flag_minQuestions > 0 || soap_flag_defQuestions > 0 || soap_flag_maxQuestions > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getTestConfigOutput(struct soap *soap, const struct swad__getTestConfigOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getTestConfigOutput);
	if (soap_out_swad__getTestConfigOutput(soap, tag?tag:"swad:getTestConfigOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getTestConfigOutput * SOAP_FMAC4 soap_get_swad__getTestConfigOutput(struct soap *soap, struct swad__getTestConfigOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getTestConfigOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__markNotificationsAsReadOutput(struct soap *soap, struct swad__markNotificationsAsReadOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->numNotifications);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__markNotificationsAsReadOutput(struct soap *soap, const struct swad__markNotificationsAsReadOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__markNotificationsAsReadOutput(struct soap *soap, const char *tag, int id, const struct swad__markNotificationsAsReadOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__markNotificationsAsReadOutput), type))
		return soap->error;
	if (soap_out_int(soap, "numNotifications", -1, &a->numNotifications, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__markNotificationsAsReadOutput * SOAP_FMAC4 soap_in_swad__markNotificationsAsReadOutput(struct soap *soap, const char *tag, struct swad__markNotificationsAsReadOutput *a, const char *type)
{
	size_t soap_flag_numNotifications = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__markNotificationsAsReadOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__markNotificationsAsReadOutput, sizeof(struct swad__markNotificationsAsReadOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__markNotificationsAsReadOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_numNotifications && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numNotifications", &a->numNotifications, "xsd:int"))
				{	soap_flag_numNotifications--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__markNotificationsAsReadOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__markNotificationsAsReadOutput, 0, sizeof(struct swad__markNotificationsAsReadOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_numNotifications > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__markNotificationsAsReadOutput(struct soap *soap, const struct swad__markNotificationsAsReadOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__markNotificationsAsReadOutput);
	if (soap_out_swad__markNotificationsAsReadOutput(soap, tag?tag:"swad:markNotificationsAsReadOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__markNotificationsAsReadOutput * SOAP_FMAC4 soap_get_swad__markNotificationsAsReadOutput(struct soap *soap, struct swad__markNotificationsAsReadOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__markNotificationsAsReadOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getNotificationsOutput(struct soap *soap, struct swad__getNotificationsOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->numNotifications);
	soap_default_swad__notificationsArray(soap, &a->notificationsArray);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getNotificationsOutput(struct soap *soap, const struct swad__getNotificationsOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_swad__notificationsArray(soap, &a->notificationsArray);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getNotificationsOutput(struct soap *soap, const char *tag, int id, const struct swad__getNotificationsOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getNotificationsOutput), type))
		return soap->error;
	if (soap_out_int(soap, "numNotifications", -1, &a->numNotifications, ""))
		return soap->error;
	if (soap_out_swad__notificationsArray(soap, "notificationsArray", -1, &a->notificationsArray, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getNotificationsOutput * SOAP_FMAC4 soap_in_swad__getNotificationsOutput(struct soap *soap, const char *tag, struct swad__getNotificationsOutput *a, const char *type)
{
	size_t soap_flag_numNotifications = 1;
	size_t soap_flag_notificationsArray = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getNotificationsOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getNotificationsOutput, sizeof(struct swad__getNotificationsOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getNotificationsOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_numNotifications && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numNotifications", &a->numNotifications, "xsd:int"))
				{	soap_flag_numNotifications--;
					continue;
				}
			if (soap_flag_notificationsArray && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_swad__notificationsArray(soap, "notificationsArray", &a->notificationsArray, "swad:notificationsArray"))
				{	soap_flag_notificationsArray--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getNotificationsOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getNotificationsOutput, 0, sizeof(struct swad__getNotificationsOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_numNotifications > 0 || soap_flag_notificationsArray > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getNotificationsOutput(struct soap *soap, const struct swad__getNotificationsOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getNotificationsOutput);
	if (soap_out_swad__getNotificationsOutput(soap, tag?tag:"swad:getNotificationsOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getNotificationsOutput * SOAP_FMAC4 soap_get_swad__getNotificationsOutput(struct soap *soap, struct swad__getNotificationsOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getNotificationsOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__notificationsArray(struct soap *soap, struct swad__notificationsArray *a)
{	(void)soap;
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__notificationsArray(struct soap *soap, struct swad__notificationsArray const*a)
{
#ifndef WITH_NOIDREF
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)(void*)&a->__ptr, 1, SOAP_TYPE_swad__notificationsArray))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_swad__notification);
			soap_serialize_swad__notification(soap, a->__ptr + i);
		}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__notificationsArray(struct soap *soap, const char *tag, int id, const struct swad__notificationsArray *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)(void*)&a->__ptr, 1, type, SOAP_TYPE_swad__notificationsArray);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_swad__notification(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__notificationsArray * SOAP_FMAC4 soap_in_swad__notificationsArray(struct soap *soap, const char *tag, struct swad__notificationsArray *a, const char *type)
{	int i, j;
	struct swad__notification *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "swad:notification") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct swad__notificationsArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__notificationsArray, sizeof(struct swad__notificationsArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__notificationsArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct swad__notification *)soap_malloc(soap, sizeof(struct swad__notification) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_swad__notification(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_swad__notification(soap, NULL, a->__ptr + i, "swad:notification"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct swad__notification *)soap_push_block(soap, NULL, sizeof(struct swad__notification));
				if (!p)
					return NULL;
				soap_default_swad__notification(soap, p);
				if (!soap_in_swad__notification(soap, NULL, p, "swad:notification"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct swad__notification *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__notificationsArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__notificationsArray, 0, sizeof(struct swad__notificationsArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__notificationsArray(struct soap *soap, const struct swad__notificationsArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)(void*)&a->__ptr, 1, tag, SOAP_TYPE_swad__notificationsArray);
	if (soap_out_swad__notificationsArray(soap, tag?tag:"swad:notificationsArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__notificationsArray * SOAP_FMAC4 soap_get_swad__notificationsArray(struct soap *soap, struct swad__notificationsArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__notificationsArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__notification(struct soap *soap, struct swad__notification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->notifCode);
	soap_default_string(soap, &a->eventType);
	soap_default_int(soap, &a->eventCode);
	soap_default_long(soap, &a->eventTime);
	soap_default_string(soap, &a->userNickname);
	soap_default_string(soap, &a->userSurname1);
	soap_default_string(soap, &a->userSurname2);
	soap_default_string(soap, &a->userFirstname);
	soap_default_string(soap, &a->userPhoto);
	soap_default_string(soap, &a->location);
	soap_default_int(soap, &a->status);
	soap_default_string(soap, &a->summary);
	soap_default_string(soap, &a->content);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__notification(struct soap *soap, const struct swad__notification *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->eventType);
	soap_serialize_string(soap, &a->userNickname);
	soap_serialize_string(soap, &a->userSurname1);
	soap_serialize_string(soap, &a->userSurname2);
	soap_serialize_string(soap, &a->userFirstname);
	soap_serialize_string(soap, &a->userPhoto);
	soap_serialize_string(soap, &a->location);
	soap_serialize_string(soap, &a->summary);
	soap_serialize_string(soap, &a->content);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__notification(struct soap *soap, const char *tag, int id, const struct swad__notification *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__notification), type))
		return soap->error;
	if (soap_out_int(soap, "notifCode", -1, &a->notifCode, ""))
		return soap->error;
	if (soap_out_string(soap, "eventType", -1, &a->eventType, ""))
		return soap->error;
	if (soap_out_int(soap, "eventCode", -1, &a->eventCode, ""))
		return soap->error;
	if (soap_out_long(soap, "eventTime", -1, &a->eventTime, ""))
		return soap->error;
	if (soap_out_string(soap, "userNickname", -1, &a->userNickname, ""))
		return soap->error;
	if (soap_out_string(soap, "userSurname1", -1, &a->userSurname1, ""))
		return soap->error;
	if (soap_out_string(soap, "userSurname2", -1, &a->userSurname2, ""))
		return soap->error;
	if (soap_out_string(soap, "userFirstname", -1, &a->userFirstname, ""))
		return soap->error;
	if (soap_out_string(soap, "userPhoto", -1, &a->userPhoto, ""))
		return soap->error;
	if (soap_out_string(soap, "location", -1, &a->location, ""))
		return soap->error;
	if (soap_out_int(soap, "status", -1, &a->status, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	if (soap_out_string(soap, "content", -1, &a->content, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__notification * SOAP_FMAC4 soap_in_swad__notification(struct soap *soap, const char *tag, struct swad__notification *a, const char *type)
{
	size_t soap_flag_notifCode = 1;
	size_t soap_flag_eventType = 1;
	size_t soap_flag_eventCode = 1;
	size_t soap_flag_eventTime = 1;
	size_t soap_flag_userNickname = 1;
	size_t soap_flag_userSurname1 = 1;
	size_t soap_flag_userSurname2 = 1;
	size_t soap_flag_userFirstname = 1;
	size_t soap_flag_userPhoto = 1;
	size_t soap_flag_location = 1;
	size_t soap_flag_status = 1;
	size_t soap_flag_summary = 1;
	size_t soap_flag_content = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__notification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__notification, sizeof(struct swad__notification), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__notification(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_notifCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "notifCode", &a->notifCode, "xsd:int"))
				{	soap_flag_notifCode--;
					continue;
				}
			if (soap_flag_eventType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "eventType", &a->eventType, "xsd:string"))
				{	soap_flag_eventType--;
					continue;
				}
			if (soap_flag_eventCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "eventCode", &a->eventCode, "xsd:int"))
				{	soap_flag_eventCode--;
					continue;
				}
			if (soap_flag_eventTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "eventTime", &a->eventTime, "xsd:long"))
				{	soap_flag_eventTime--;
					continue;
				}
			if (soap_flag_userNickname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userNickname", &a->userNickname, "xsd:string"))
				{	soap_flag_userNickname--;
					continue;
				}
			if (soap_flag_userSurname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userSurname1", &a->userSurname1, "xsd:string"))
				{	soap_flag_userSurname1--;
					continue;
				}
			if (soap_flag_userSurname2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userSurname2", &a->userSurname2, "xsd:string"))
				{	soap_flag_userSurname2--;
					continue;
				}
			if (soap_flag_userFirstname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userFirstname", &a->userFirstname, "xsd:string"))
				{	soap_flag_userFirstname--;
					continue;
				}
			if (soap_flag_userPhoto && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userPhoto", &a->userPhoto, "xsd:string"))
				{	soap_flag_userPhoto--;
					continue;
				}
			if (soap_flag_location && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "location", &a->location, "xsd:string"))
				{	soap_flag_location--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap_flag_content && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "content", &a->content, "xsd:string"))
				{	soap_flag_content--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__notification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__notification, 0, sizeof(struct swad__notification), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_notifCode > 0 || soap_flag_eventCode > 0 || soap_flag_eventTime > 0 || soap_flag_status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__notification(struct soap *soap, const struct swad__notification *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__notification);
	if (soap_out_swad__notification(soap, tag?tag:"swad:notification", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__notification * SOAP_FMAC4 soap_get_swad__notification(struct soap *soap, struct swad__notification *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__notification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__sendMyGroupsOutput(struct soap *soap, struct swad__sendMyGroupsOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->success);
	soap_default_int(soap, &a->numGroups);
	soap_default_swad__groupsArray(soap, &a->groupsArray);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__sendMyGroupsOutput(struct soap *soap, const struct swad__sendMyGroupsOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_swad__groupsArray(soap, &a->groupsArray);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__sendMyGroupsOutput(struct soap *soap, const char *tag, int id, const struct swad__sendMyGroupsOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__sendMyGroupsOutput), type))
		return soap->error;
	if (soap_out_int(soap, "success", -1, &a->success, ""))
		return soap->error;
	if (soap_out_int(soap, "numGroups", -1, &a->numGroups, ""))
		return soap->error;
	if (soap_out_swad__groupsArray(soap, "groupsArray", -1, &a->groupsArray, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__sendMyGroupsOutput * SOAP_FMAC4 soap_in_swad__sendMyGroupsOutput(struct soap *soap, const char *tag, struct swad__sendMyGroupsOutput *a, const char *type)
{
	size_t soap_flag_success = 1;
	size_t soap_flag_numGroups = 1;
	size_t soap_flag_groupsArray = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__sendMyGroupsOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__sendMyGroupsOutput, sizeof(struct swad__sendMyGroupsOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__sendMyGroupsOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_success && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "success", &a->success, "xsd:int"))
				{	soap_flag_success--;
					continue;
				}
			if (soap_flag_numGroups && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numGroups", &a->numGroups, "xsd:int"))
				{	soap_flag_numGroups--;
					continue;
				}
			if (soap_flag_groupsArray && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_swad__groupsArray(soap, "groupsArray", &a->groupsArray, "swad:groupsArray"))
				{	soap_flag_groupsArray--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__sendMyGroupsOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__sendMyGroupsOutput, 0, sizeof(struct swad__sendMyGroupsOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_success > 0 || soap_flag_numGroups > 0 || soap_flag_groupsArray > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__sendMyGroupsOutput(struct soap *soap, const struct swad__sendMyGroupsOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__sendMyGroupsOutput);
	if (soap_out_swad__sendMyGroupsOutput(soap, tag?tag:"swad:sendMyGroupsOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__sendMyGroupsOutput * SOAP_FMAC4 soap_get_swad__sendMyGroupsOutput(struct soap *soap, struct swad__sendMyGroupsOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__sendMyGroupsOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getGroupsOutput(struct soap *soap, struct swad__getGroupsOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->numGroups);
	soap_default_swad__groupsArray(soap, &a->groupsArray);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getGroupsOutput(struct soap *soap, const struct swad__getGroupsOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_swad__groupsArray(soap, &a->groupsArray);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getGroupsOutput(struct soap *soap, const char *tag, int id, const struct swad__getGroupsOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getGroupsOutput), type))
		return soap->error;
	if (soap_out_int(soap, "numGroups", -1, &a->numGroups, ""))
		return soap->error;
	if (soap_out_swad__groupsArray(soap, "groupsArray", -1, &a->groupsArray, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getGroupsOutput * SOAP_FMAC4 soap_in_swad__getGroupsOutput(struct soap *soap, const char *tag, struct swad__getGroupsOutput *a, const char *type)
{
	size_t soap_flag_numGroups = 1;
	size_t soap_flag_groupsArray = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getGroupsOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getGroupsOutput, sizeof(struct swad__getGroupsOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getGroupsOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_numGroups && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numGroups", &a->numGroups, "xsd:int"))
				{	soap_flag_numGroups--;
					continue;
				}
			if (soap_flag_groupsArray && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_swad__groupsArray(soap, "groupsArray", &a->groupsArray, "swad:groupsArray"))
				{	soap_flag_groupsArray--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getGroupsOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getGroupsOutput, 0, sizeof(struct swad__getGroupsOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_numGroups > 0 || soap_flag_groupsArray > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getGroupsOutput(struct soap *soap, const struct swad__getGroupsOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getGroupsOutput);
	if (soap_out_swad__getGroupsOutput(soap, tag?tag:"swad:getGroupsOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getGroupsOutput * SOAP_FMAC4 soap_get_swad__getGroupsOutput(struct soap *soap, struct swad__getGroupsOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getGroupsOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__groupsArray(struct soap *soap, struct swad__groupsArray *a)
{	(void)soap;
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__groupsArray(struct soap *soap, struct swad__groupsArray const*a)
{
#ifndef WITH_NOIDREF
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)(void*)&a->__ptr, 1, SOAP_TYPE_swad__groupsArray))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_swad__group);
			soap_serialize_swad__group(soap, a->__ptr + i);
		}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__groupsArray(struct soap *soap, const char *tag, int id, const struct swad__groupsArray *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)(void*)&a->__ptr, 1, type, SOAP_TYPE_swad__groupsArray);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_swad__group(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__groupsArray * SOAP_FMAC4 soap_in_swad__groupsArray(struct soap *soap, const char *tag, struct swad__groupsArray *a, const char *type)
{	int i, j;
	struct swad__group *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "swad:group") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct swad__groupsArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__groupsArray, sizeof(struct swad__groupsArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__groupsArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct swad__group *)soap_malloc(soap, sizeof(struct swad__group) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_swad__group(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_swad__group(soap, NULL, a->__ptr + i, "swad:group"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct swad__group *)soap_push_block(soap, NULL, sizeof(struct swad__group));
				if (!p)
					return NULL;
				soap_default_swad__group(soap, p);
				if (!soap_in_swad__group(soap, NULL, p, "swad:group"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct swad__group *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__groupsArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__groupsArray, 0, sizeof(struct swad__groupsArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__groupsArray(struct soap *soap, const struct swad__groupsArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)(void*)&a->__ptr, 1, tag, SOAP_TYPE_swad__groupsArray);
	if (soap_out_swad__groupsArray(soap, tag?tag:"swad:groupsArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__groupsArray * SOAP_FMAC4 soap_get_swad__groupsArray(struct soap *soap, struct swad__groupsArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__groupsArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__group(struct soap *soap, struct swad__group *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->groupCode);
	soap_default_string(soap, &a->groupName);
	soap_default_int(soap, &a->groupTypeCode);
	soap_default_string(soap, &a->groupTypeName);
	soap_default_int(soap, &a->open);
	soap_default_int(soap, &a->maxStudents);
	soap_default_int(soap, &a->numStudents);
	soap_default_int(soap, &a->fileZones);
	soap_default_int(soap, &a->member);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__group(struct soap *soap, const struct swad__group *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->groupName);
	soap_serialize_string(soap, &a->groupTypeName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__group(struct soap *soap, const char *tag, int id, const struct swad__group *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__group), type))
		return soap->error;
	if (soap_out_int(soap, "groupCode", -1, &a->groupCode, ""))
		return soap->error;
	if (soap_out_string(soap, "groupName", -1, &a->groupName, ""))
		return soap->error;
	if (soap_out_int(soap, "groupTypeCode", -1, &a->groupTypeCode, ""))
		return soap->error;
	if (soap_out_string(soap, "groupTypeName", -1, &a->groupTypeName, ""))
		return soap->error;
	if (soap_out_int(soap, "open", -1, &a->open, ""))
		return soap->error;
	if (soap_out_int(soap, "maxStudents", -1, &a->maxStudents, ""))
		return soap->error;
	if (soap_out_int(soap, "numStudents", -1, &a->numStudents, ""))
		return soap->error;
	if (soap_out_int(soap, "fileZones", -1, &a->fileZones, ""))
		return soap->error;
	if (soap_out_int(soap, "member", -1, &a->member, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__group * SOAP_FMAC4 soap_in_swad__group(struct soap *soap, const char *tag, struct swad__group *a, const char *type)
{
	size_t soap_flag_groupCode = 1;
	size_t soap_flag_groupName = 1;
	size_t soap_flag_groupTypeCode = 1;
	size_t soap_flag_groupTypeName = 1;
	size_t soap_flag_open = 1;
	size_t soap_flag_maxStudents = 1;
	size_t soap_flag_numStudents = 1;
	size_t soap_flag_fileZones = 1;
	size_t soap_flag_member = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__group *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__group, sizeof(struct swad__group), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__group(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_groupCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "groupCode", &a->groupCode, "xsd:int"))
				{	soap_flag_groupCode--;
					continue;
				}
			if (soap_flag_groupName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "groupName", &a->groupName, "xsd:string"))
				{	soap_flag_groupName--;
					continue;
				}
			if (soap_flag_groupTypeCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "groupTypeCode", &a->groupTypeCode, "xsd:int"))
				{	soap_flag_groupTypeCode--;
					continue;
				}
			if (soap_flag_groupTypeName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "groupTypeName", &a->groupTypeName, "xsd:string"))
				{	soap_flag_groupTypeName--;
					continue;
				}
			if (soap_flag_open && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "open", &a->open, "xsd:int"))
				{	soap_flag_open--;
					continue;
				}
			if (soap_flag_maxStudents && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "maxStudents", &a->maxStudents, "xsd:int"))
				{	soap_flag_maxStudents--;
					continue;
				}
			if (soap_flag_numStudents && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numStudents", &a->numStudents, "xsd:int"))
				{	soap_flag_numStudents--;
					continue;
				}
			if (soap_flag_fileZones && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "fileZones", &a->fileZones, "xsd:int"))
				{	soap_flag_fileZones--;
					continue;
				}
			if (soap_flag_member && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "member", &a->member, "xsd:int"))
				{	soap_flag_member--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__group *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__group, 0, sizeof(struct swad__group), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_groupCode > 0 || soap_flag_groupTypeCode > 0 || soap_flag_open > 0 || soap_flag_maxStudents > 0 || soap_flag_numStudents > 0 || soap_flag_fileZones > 0 || soap_flag_member > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__group(struct soap *soap, const struct swad__group *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__group);
	if (soap_out_swad__group(soap, tag?tag:"swad:group", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__group * SOAP_FMAC4 soap_get_swad__group(struct soap *soap, struct swad__group *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__group(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getGroupTypesOutput(struct soap *soap, struct swad__getGroupTypesOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->numGroupTypes);
	soap_default_swad__groupTypesArray(soap, &a->groupTypesArray);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getGroupTypesOutput(struct soap *soap, const struct swad__getGroupTypesOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_swad__groupTypesArray(soap, &a->groupTypesArray);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getGroupTypesOutput(struct soap *soap, const char *tag, int id, const struct swad__getGroupTypesOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getGroupTypesOutput), type))
		return soap->error;
	if (soap_out_int(soap, "numGroupTypes", -1, &a->numGroupTypes, ""))
		return soap->error;
	if (soap_out_swad__groupTypesArray(soap, "groupTypesArray", -1, &a->groupTypesArray, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getGroupTypesOutput * SOAP_FMAC4 soap_in_swad__getGroupTypesOutput(struct soap *soap, const char *tag, struct swad__getGroupTypesOutput *a, const char *type)
{
	size_t soap_flag_numGroupTypes = 1;
	size_t soap_flag_groupTypesArray = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getGroupTypesOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getGroupTypesOutput, sizeof(struct swad__getGroupTypesOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getGroupTypesOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_numGroupTypes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numGroupTypes", &a->numGroupTypes, "xsd:int"))
				{	soap_flag_numGroupTypes--;
					continue;
				}
			if (soap_flag_groupTypesArray && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_swad__groupTypesArray(soap, "groupTypesArray", &a->groupTypesArray, "swad:groupTypesArray"))
				{	soap_flag_groupTypesArray--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getGroupTypesOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getGroupTypesOutput, 0, sizeof(struct swad__getGroupTypesOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_numGroupTypes > 0 || soap_flag_groupTypesArray > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getGroupTypesOutput(struct soap *soap, const struct swad__getGroupTypesOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getGroupTypesOutput);
	if (soap_out_swad__getGroupTypesOutput(soap, tag?tag:"swad:getGroupTypesOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getGroupTypesOutput * SOAP_FMAC4 soap_get_swad__getGroupTypesOutput(struct soap *soap, struct swad__getGroupTypesOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getGroupTypesOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__groupTypesArray(struct soap *soap, struct swad__groupTypesArray *a)
{	(void)soap;
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__groupTypesArray(struct soap *soap, struct swad__groupTypesArray const*a)
{
#ifndef WITH_NOIDREF
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)(void*)&a->__ptr, 1, SOAP_TYPE_swad__groupTypesArray))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_swad__groupType);
			soap_serialize_swad__groupType(soap, a->__ptr + i);
		}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__groupTypesArray(struct soap *soap, const char *tag, int id, const struct swad__groupTypesArray *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)(void*)&a->__ptr, 1, type, SOAP_TYPE_swad__groupTypesArray);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_swad__groupType(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__groupTypesArray * SOAP_FMAC4 soap_in_swad__groupTypesArray(struct soap *soap, const char *tag, struct swad__groupTypesArray *a, const char *type)
{	int i, j;
	struct swad__groupType *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "swad:groupType") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct swad__groupTypesArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__groupTypesArray, sizeof(struct swad__groupTypesArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__groupTypesArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct swad__groupType *)soap_malloc(soap, sizeof(struct swad__groupType) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_swad__groupType(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_swad__groupType(soap, NULL, a->__ptr + i, "swad:groupType"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct swad__groupType *)soap_push_block(soap, NULL, sizeof(struct swad__groupType));
				if (!p)
					return NULL;
				soap_default_swad__groupType(soap, p);
				if (!soap_in_swad__groupType(soap, NULL, p, "swad:groupType"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct swad__groupType *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__groupTypesArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__groupTypesArray, 0, sizeof(struct swad__groupTypesArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__groupTypesArray(struct soap *soap, const struct swad__groupTypesArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)(void*)&a->__ptr, 1, tag, SOAP_TYPE_swad__groupTypesArray);
	if (soap_out_swad__groupTypesArray(soap, tag?tag:"swad:groupTypesArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__groupTypesArray * SOAP_FMAC4 soap_get_swad__groupTypesArray(struct soap *soap, struct swad__groupTypesArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__groupTypesArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__groupType(struct soap *soap, struct swad__groupType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->groupTypeCode);
	soap_default_string(soap, &a->groupTypeName);
	soap_default_int(soap, &a->mandatory);
	soap_default_int(soap, &a->multiple);
	soap_default_long(soap, &a->openTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__groupType(struct soap *soap, const struct swad__groupType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->groupTypeName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__groupType(struct soap *soap, const char *tag, int id, const struct swad__groupType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__groupType), type))
		return soap->error;
	if (soap_out_int(soap, "groupTypeCode", -1, &a->groupTypeCode, ""))
		return soap->error;
	if (soap_out_string(soap, "groupTypeName", -1, &a->groupTypeName, ""))
		return soap->error;
	if (soap_out_int(soap, "mandatory", -1, &a->mandatory, ""))
		return soap->error;
	if (soap_out_int(soap, "multiple", -1, &a->multiple, ""))
		return soap->error;
	if (soap_out_long(soap, "openTime", -1, &a->openTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__groupType * SOAP_FMAC4 soap_in_swad__groupType(struct soap *soap, const char *tag, struct swad__groupType *a, const char *type)
{
	size_t soap_flag_groupTypeCode = 1;
	size_t soap_flag_groupTypeName = 1;
	size_t soap_flag_mandatory = 1;
	size_t soap_flag_multiple = 1;
	size_t soap_flag_openTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__groupType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__groupType, sizeof(struct swad__groupType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__groupType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_groupTypeCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "groupTypeCode", &a->groupTypeCode, "xsd:int"))
				{	soap_flag_groupTypeCode--;
					continue;
				}
			if (soap_flag_groupTypeName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "groupTypeName", &a->groupTypeName, "xsd:string"))
				{	soap_flag_groupTypeName--;
					continue;
				}
			if (soap_flag_mandatory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mandatory", &a->mandatory, "xsd:int"))
				{	soap_flag_mandatory--;
					continue;
				}
			if (soap_flag_multiple && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "multiple", &a->multiple, "xsd:int"))
				{	soap_flag_multiple--;
					continue;
				}
			if (soap_flag_openTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "openTime", &a->openTime, "xsd:long"))
				{	soap_flag_openTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__groupType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__groupType, 0, sizeof(struct swad__groupType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_groupTypeCode > 0 || soap_flag_mandatory > 0 || soap_flag_multiple > 0 || soap_flag_openTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__groupType(struct soap *soap, const struct swad__groupType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__groupType);
	if (soap_out_swad__groupType(soap, tag?tag:"swad:groupType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__groupType * SOAP_FMAC4 soap_get_swad__groupType(struct soap *soap, struct swad__groupType *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__groupType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getCourseInfoOutput(struct soap *soap, struct swad__getCourseInfoOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->infoSrc);
	soap_default_string(soap, &a->infoTxt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getCourseInfoOutput(struct soap *soap, const struct swad__getCourseInfoOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->infoSrc);
	soap_serialize_string(soap, &a->infoTxt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getCourseInfoOutput(struct soap *soap, const char *tag, int id, const struct swad__getCourseInfoOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getCourseInfoOutput), type))
		return soap->error;
	if (soap_out_string(soap, "infoSrc", -1, &a->infoSrc, ""))
		return soap->error;
	if (soap_out_string(soap, "infoTxt", -1, &a->infoTxt, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getCourseInfoOutput * SOAP_FMAC4 soap_in_swad__getCourseInfoOutput(struct soap *soap, const char *tag, struct swad__getCourseInfoOutput *a, const char *type)
{
	size_t soap_flag_infoSrc = 1;
	size_t soap_flag_infoTxt = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getCourseInfoOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getCourseInfoOutput, sizeof(struct swad__getCourseInfoOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getCourseInfoOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_infoSrc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "infoSrc", &a->infoSrc, "xsd:string"))
				{	soap_flag_infoSrc--;
					continue;
				}
			if (soap_flag_infoTxt && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "infoTxt", &a->infoTxt, "xsd:string"))
				{	soap_flag_infoTxt--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getCourseInfoOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getCourseInfoOutput, 0, sizeof(struct swad__getCourseInfoOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getCourseInfoOutput(struct soap *soap, const struct swad__getCourseInfoOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getCourseInfoOutput);
	if (soap_out_swad__getCourseInfoOutput(soap, tag?tag:"swad:getCourseInfoOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getCourseInfoOutput * SOAP_FMAC4 soap_get_swad__getCourseInfoOutput(struct soap *soap, struct swad__getCourseInfoOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getCourseInfoOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getCoursesOutput(struct soap *soap, struct swad__getCoursesOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->numCourses);
	soap_default_swad__coursesArray(soap, &a->coursesArray);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getCoursesOutput(struct soap *soap, const struct swad__getCoursesOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_swad__coursesArray(soap, &a->coursesArray);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getCoursesOutput(struct soap *soap, const char *tag, int id, const struct swad__getCoursesOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getCoursesOutput), type))
		return soap->error;
	if (soap_out_int(soap, "numCourses", -1, &a->numCourses, ""))
		return soap->error;
	if (soap_out_swad__coursesArray(soap, "coursesArray", -1, &a->coursesArray, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getCoursesOutput * SOAP_FMAC4 soap_in_swad__getCoursesOutput(struct soap *soap, const char *tag, struct swad__getCoursesOutput *a, const char *type)
{
	size_t soap_flag_numCourses = 1;
	size_t soap_flag_coursesArray = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getCoursesOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getCoursesOutput, sizeof(struct swad__getCoursesOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getCoursesOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_numCourses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numCourses", &a->numCourses, "xsd:int"))
				{	soap_flag_numCourses--;
					continue;
				}
			if (soap_flag_coursesArray && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_swad__coursesArray(soap, "coursesArray", &a->coursesArray, "swad:coursesArray"))
				{	soap_flag_coursesArray--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getCoursesOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getCoursesOutput, 0, sizeof(struct swad__getCoursesOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_numCourses > 0 || soap_flag_coursesArray > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getCoursesOutput(struct soap *soap, const struct swad__getCoursesOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getCoursesOutput);
	if (soap_out_swad__getCoursesOutput(soap, tag?tag:"swad:getCoursesOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getCoursesOutput * SOAP_FMAC4 soap_get_swad__getCoursesOutput(struct soap *soap, struct swad__getCoursesOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getCoursesOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__coursesArray(struct soap *soap, struct swad__coursesArray *a)
{	(void)soap;
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__coursesArray(struct soap *soap, struct swad__coursesArray const*a)
{
#ifndef WITH_NOIDREF
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)(void*)&a->__ptr, 1, SOAP_TYPE_swad__coursesArray))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_swad__course);
			soap_serialize_swad__course(soap, a->__ptr + i);
		}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__coursesArray(struct soap *soap, const char *tag, int id, const struct swad__coursesArray *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)(void*)&a->__ptr, 1, type, SOAP_TYPE_swad__coursesArray);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_swad__course(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__coursesArray * SOAP_FMAC4 soap_in_swad__coursesArray(struct soap *soap, const char *tag, struct swad__coursesArray *a, const char *type)
{	int i, j;
	struct swad__course *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "swad:course") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct swad__coursesArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__coursesArray, sizeof(struct swad__coursesArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__coursesArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct swad__course *)soap_malloc(soap, sizeof(struct swad__course) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_swad__course(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_swad__course(soap, NULL, a->__ptr + i, "swad:course"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct swad__course *)soap_push_block(soap, NULL, sizeof(struct swad__course));
				if (!p)
					return NULL;
				soap_default_swad__course(soap, p);
				if (!soap_in_swad__course(soap, NULL, p, "swad:course"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct swad__course *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__coursesArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__coursesArray, 0, sizeof(struct swad__coursesArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__coursesArray(struct soap *soap, const struct swad__coursesArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)(void*)&a->__ptr, 1, tag, SOAP_TYPE_swad__coursesArray);
	if (soap_out_swad__coursesArray(soap, tag?tag:"swad:coursesArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__coursesArray * SOAP_FMAC4 soap_get_swad__coursesArray(struct soap *soap, struct swad__coursesArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__coursesArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__course(struct soap *soap, struct swad__course *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->courseCode);
	soap_default_string(soap, &a->courseShortName);
	soap_default_string(soap, &a->courseFullName);
	soap_default_int(soap, &a->userRole);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__course(struct soap *soap, const struct swad__course *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->courseShortName);
	soap_serialize_string(soap, &a->courseFullName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__course(struct soap *soap, const char *tag, int id, const struct swad__course *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__course), type))
		return soap->error;
	if (soap_out_int(soap, "courseCode", -1, &a->courseCode, ""))
		return soap->error;
	if (soap_out_string(soap, "courseShortName", -1, &a->courseShortName, ""))
		return soap->error;
	if (soap_out_string(soap, "courseFullName", -1, &a->courseFullName, ""))
		return soap->error;
	if (soap_out_int(soap, "userRole", -1, &a->userRole, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__course * SOAP_FMAC4 soap_in_swad__course(struct soap *soap, const char *tag, struct swad__course *a, const char *type)
{
	size_t soap_flag_courseCode = 1;
	size_t soap_flag_courseShortName = 1;
	size_t soap_flag_courseFullName = 1;
	size_t soap_flag_userRole = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__course *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__course, sizeof(struct swad__course), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__course(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_courseCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "courseCode", &a->courseCode, "xsd:int"))
				{	soap_flag_courseCode--;
					continue;
				}
			if (soap_flag_courseShortName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "courseShortName", &a->courseShortName, "xsd:string"))
				{	soap_flag_courseShortName--;
					continue;
				}
			if (soap_flag_courseFullName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "courseFullName", &a->courseFullName, "xsd:string"))
				{	soap_flag_courseFullName--;
					continue;
				}
			if (soap_flag_userRole && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "userRole", &a->userRole, "xsd:int"))
				{	soap_flag_userRole--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__course *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__course, 0, sizeof(struct swad__course), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_courseCode > 0 || soap_flag_userRole > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__course(struct soap *soap, const struct swad__course *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__course);
	if (soap_out_swad__course(soap, tag?tag:"swad:course", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__course * SOAP_FMAC4 soap_get_swad__course(struct soap *soap, struct swad__course *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__course(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__getNewPasswordOutput(struct soap *soap, struct swad__getNewPasswordOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->success);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__getNewPasswordOutput(struct soap *soap, const struct swad__getNewPasswordOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__getNewPasswordOutput(struct soap *soap, const char *tag, int id, const struct swad__getNewPasswordOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__getNewPasswordOutput), type))
		return soap->error;
	if (soap_out_int(soap, "success", -1, &a->success, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__getNewPasswordOutput * SOAP_FMAC4 soap_in_swad__getNewPasswordOutput(struct soap *soap, const char *tag, struct swad__getNewPasswordOutput *a, const char *type)
{
	size_t soap_flag_success = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__getNewPasswordOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__getNewPasswordOutput, sizeof(struct swad__getNewPasswordOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__getNewPasswordOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_success && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "success", &a->success, "xsd:int"))
				{	soap_flag_success--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__getNewPasswordOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__getNewPasswordOutput, 0, sizeof(struct swad__getNewPasswordOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_success > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__getNewPasswordOutput(struct soap *soap, const struct swad__getNewPasswordOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__getNewPasswordOutput);
	if (soap_out_swad__getNewPasswordOutput(soap, tag?tag:"swad:getNewPasswordOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getNewPasswordOutput * SOAP_FMAC4 soap_get_swad__getNewPasswordOutput(struct soap *soap, struct swad__getNewPasswordOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__getNewPasswordOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__loginByUserPasswordKeyOutput(struct soap *soap, struct swad__loginByUserPasswordKeyOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->userCode);
	soap_default_string(soap, &a->wsKey);
	soap_default_string(soap, &a->userNickname);
	soap_default_string(soap, &a->userID);
	soap_default_string(soap, &a->userSurname1);
	soap_default_string(soap, &a->userSurname2);
	soap_default_string(soap, &a->userFirstname);
	soap_default_string(soap, &a->userPhoto);
	soap_default_string(soap, &a->userBirthday);
	soap_default_int(soap, &a->userRole);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__loginByUserPasswordKeyOutput(struct soap *soap, const struct swad__loginByUserPasswordKeyOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsKey);
	soap_serialize_string(soap, &a->userNickname);
	soap_serialize_string(soap, &a->userID);
	soap_serialize_string(soap, &a->userSurname1);
	soap_serialize_string(soap, &a->userSurname2);
	soap_serialize_string(soap, &a->userFirstname);
	soap_serialize_string(soap, &a->userPhoto);
	soap_serialize_string(soap, &a->userBirthday);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__loginByUserPasswordKeyOutput(struct soap *soap, const char *tag, int id, const struct swad__loginByUserPasswordKeyOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__loginByUserPasswordKeyOutput), type))
		return soap->error;
	if (soap_out_int(soap, "userCode", -1, &a->userCode, ""))
		return soap->error;
	if (soap_out_string(soap, "wsKey", -1, &a->wsKey, ""))
		return soap->error;
	if (soap_out_string(soap, "userNickname", -1, &a->userNickname, ""))
		return soap->error;
	if (soap_out_string(soap, "userID", -1, &a->userID, ""))
		return soap->error;
	if (soap_out_string(soap, "userSurname1", -1, &a->userSurname1, ""))
		return soap->error;
	if (soap_out_string(soap, "userSurname2", -1, &a->userSurname2, ""))
		return soap->error;
	if (soap_out_string(soap, "userFirstname", -1, &a->userFirstname, ""))
		return soap->error;
	if (soap_out_string(soap, "userPhoto", -1, &a->userPhoto, ""))
		return soap->error;
	if (soap_out_string(soap, "userBirthday", -1, &a->userBirthday, ""))
		return soap->error;
	if (soap_out_int(soap, "userRole", -1, &a->userRole, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__loginByUserPasswordKeyOutput * SOAP_FMAC4 soap_in_swad__loginByUserPasswordKeyOutput(struct soap *soap, const char *tag, struct swad__loginByUserPasswordKeyOutput *a, const char *type)
{
	size_t soap_flag_userCode = 1;
	size_t soap_flag_wsKey = 1;
	size_t soap_flag_userNickname = 1;
	size_t soap_flag_userID = 1;
	size_t soap_flag_userSurname1 = 1;
	size_t soap_flag_userSurname2 = 1;
	size_t soap_flag_userFirstname = 1;
	size_t soap_flag_userPhoto = 1;
	size_t soap_flag_userBirthday = 1;
	size_t soap_flag_userRole = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__loginByUserPasswordKeyOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__loginByUserPasswordKeyOutput, sizeof(struct swad__loginByUserPasswordKeyOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__loginByUserPasswordKeyOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "userCode", &a->userCode, "xsd:int"))
				{	soap_flag_userCode--;
					continue;
				}
			if (soap_flag_wsKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsKey", &a->wsKey, "xsd:string"))
				{	soap_flag_wsKey--;
					continue;
				}
			if (soap_flag_userNickname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userNickname", &a->userNickname, "xsd:string"))
				{	soap_flag_userNickname--;
					continue;
				}
			if (soap_flag_userID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userID", &a->userID, "xsd:string"))
				{	soap_flag_userID--;
					continue;
				}
			if (soap_flag_userSurname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userSurname1", &a->userSurname1, "xsd:string"))
				{	soap_flag_userSurname1--;
					continue;
				}
			if (soap_flag_userSurname2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userSurname2", &a->userSurname2, "xsd:string"))
				{	soap_flag_userSurname2--;
					continue;
				}
			if (soap_flag_userFirstname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userFirstname", &a->userFirstname, "xsd:string"))
				{	soap_flag_userFirstname--;
					continue;
				}
			if (soap_flag_userPhoto && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userPhoto", &a->userPhoto, "xsd:string"))
				{	soap_flag_userPhoto--;
					continue;
				}
			if (soap_flag_userBirthday && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userBirthday", &a->userBirthday, "xsd:string"))
				{	soap_flag_userBirthday--;
					continue;
				}
			if (soap_flag_userRole && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "userRole", &a->userRole, "xsd:int"))
				{	soap_flag_userRole--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__loginByUserPasswordKeyOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__loginByUserPasswordKeyOutput, 0, sizeof(struct swad__loginByUserPasswordKeyOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userCode > 0 || soap_flag_userRole > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__loginByUserPasswordKeyOutput(struct soap *soap, const struct swad__loginByUserPasswordKeyOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__loginByUserPasswordKeyOutput);
	if (soap_out_swad__loginByUserPasswordKeyOutput(soap, tag?tag:"swad:loginByUserPasswordKeyOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__loginByUserPasswordKeyOutput * SOAP_FMAC4 soap_get_swad__loginByUserPasswordKeyOutput(struct soap *soap, struct swad__loginByUserPasswordKeyOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__loginByUserPasswordKeyOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__loginBySessionKeyOutput(struct soap *soap, struct swad__loginBySessionKeyOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->userCode);
	soap_default_int(soap, &a->degreeTypeCode);
	soap_default_int(soap, &a->degreeCode);
	soap_default_int(soap, &a->courseCode);
	soap_default_string(soap, &a->wsKey);
	soap_default_string(soap, &a->userNickname);
	soap_default_string(soap, &a->userID);
	soap_default_string(soap, &a->userSurname1);
	soap_default_string(soap, &a->userSurname2);
	soap_default_string(soap, &a->userFirstname);
	soap_default_string(soap, &a->userPhoto);
	soap_default_string(soap, &a->userBirthday);
	soap_default_int(soap, &a->userRole);
	soap_default_string(soap, &a->degreeTypeName);
	soap_default_string(soap, &a->degreeName);
	soap_default_string(soap, &a->courseName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__loginBySessionKeyOutput(struct soap *soap, const struct swad__loginBySessionKeyOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsKey);
	soap_serialize_string(soap, &a->userNickname);
	soap_serialize_string(soap, &a->userID);
	soap_serialize_string(soap, &a->userSurname1);
	soap_serialize_string(soap, &a->userSurname2);
	soap_serialize_string(soap, &a->userFirstname);
	soap_serialize_string(soap, &a->userPhoto);
	soap_serialize_string(soap, &a->userBirthday);
	soap_serialize_string(soap, &a->degreeTypeName);
	soap_serialize_string(soap, &a->degreeName);
	soap_serialize_string(soap, &a->courseName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__loginBySessionKeyOutput(struct soap *soap, const char *tag, int id, const struct swad__loginBySessionKeyOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__loginBySessionKeyOutput), type))
		return soap->error;
	if (soap_out_int(soap, "userCode", -1, &a->userCode, ""))
		return soap->error;
	if (soap_out_int(soap, "degreeTypeCode", -1, &a->degreeTypeCode, ""))
		return soap->error;
	if (soap_out_int(soap, "degreeCode", -1, &a->degreeCode, ""))
		return soap->error;
	if (soap_out_int(soap, "courseCode", -1, &a->courseCode, ""))
		return soap->error;
	if (soap_out_string(soap, "wsKey", -1, &a->wsKey, ""))
		return soap->error;
	if (soap_out_string(soap, "userNickname", -1, &a->userNickname, ""))
		return soap->error;
	if (soap_out_string(soap, "userID", -1, &a->userID, ""))
		return soap->error;
	if (soap_out_string(soap, "userSurname1", -1, &a->userSurname1, ""))
		return soap->error;
	if (soap_out_string(soap, "userSurname2", -1, &a->userSurname2, ""))
		return soap->error;
	if (soap_out_string(soap, "userFirstname", -1, &a->userFirstname, ""))
		return soap->error;
	if (soap_out_string(soap, "userPhoto", -1, &a->userPhoto, ""))
		return soap->error;
	if (soap_out_string(soap, "userBirthday", -1, &a->userBirthday, ""))
		return soap->error;
	if (soap_out_int(soap, "userRole", -1, &a->userRole, ""))
		return soap->error;
	if (soap_out_string(soap, "degreeTypeName", -1, &a->degreeTypeName, ""))
		return soap->error;
	if (soap_out_string(soap, "degreeName", -1, &a->degreeName, ""))
		return soap->error;
	if (soap_out_string(soap, "courseName", -1, &a->courseName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__loginBySessionKeyOutput * SOAP_FMAC4 soap_in_swad__loginBySessionKeyOutput(struct soap *soap, const char *tag, struct swad__loginBySessionKeyOutput *a, const char *type)
{
	size_t soap_flag_userCode = 1;
	size_t soap_flag_degreeTypeCode = 1;
	size_t soap_flag_degreeCode = 1;
	size_t soap_flag_courseCode = 1;
	size_t soap_flag_wsKey = 1;
	size_t soap_flag_userNickname = 1;
	size_t soap_flag_userID = 1;
	size_t soap_flag_userSurname1 = 1;
	size_t soap_flag_userSurname2 = 1;
	size_t soap_flag_userFirstname = 1;
	size_t soap_flag_userPhoto = 1;
	size_t soap_flag_userBirthday = 1;
	size_t soap_flag_userRole = 1;
	size_t soap_flag_degreeTypeName = 1;
	size_t soap_flag_degreeName = 1;
	size_t soap_flag_courseName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__loginBySessionKeyOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__loginBySessionKeyOutput, sizeof(struct swad__loginBySessionKeyOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__loginBySessionKeyOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "userCode", &a->userCode, "xsd:int"))
				{	soap_flag_userCode--;
					continue;
				}
			if (soap_flag_degreeTypeCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "degreeTypeCode", &a->degreeTypeCode, "xsd:int"))
				{	soap_flag_degreeTypeCode--;
					continue;
				}
			if (soap_flag_degreeCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "degreeCode", &a->degreeCode, "xsd:int"))
				{	soap_flag_degreeCode--;
					continue;
				}
			if (soap_flag_courseCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "courseCode", &a->courseCode, "xsd:int"))
				{	soap_flag_courseCode--;
					continue;
				}
			if (soap_flag_wsKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsKey", &a->wsKey, "xsd:string"))
				{	soap_flag_wsKey--;
					continue;
				}
			if (soap_flag_userNickname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userNickname", &a->userNickname, "xsd:string"))
				{	soap_flag_userNickname--;
					continue;
				}
			if (soap_flag_userID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userID", &a->userID, "xsd:string"))
				{	soap_flag_userID--;
					continue;
				}
			if (soap_flag_userSurname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userSurname1", &a->userSurname1, "xsd:string"))
				{	soap_flag_userSurname1--;
					continue;
				}
			if (soap_flag_userSurname2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userSurname2", &a->userSurname2, "xsd:string"))
				{	soap_flag_userSurname2--;
					continue;
				}
			if (soap_flag_userFirstname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userFirstname", &a->userFirstname, "xsd:string"))
				{	soap_flag_userFirstname--;
					continue;
				}
			if (soap_flag_userPhoto && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userPhoto", &a->userPhoto, "xsd:string"))
				{	soap_flag_userPhoto--;
					continue;
				}
			if (soap_flag_userBirthday && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userBirthday", &a->userBirthday, "xsd:string"))
				{	soap_flag_userBirthday--;
					continue;
				}
			if (soap_flag_userRole && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "userRole", &a->userRole, "xsd:int"))
				{	soap_flag_userRole--;
					continue;
				}
			if (soap_flag_degreeTypeName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "degreeTypeName", &a->degreeTypeName, "xsd:string"))
				{	soap_flag_degreeTypeName--;
					continue;
				}
			if (soap_flag_degreeName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "degreeName", &a->degreeName, "xsd:string"))
				{	soap_flag_degreeName--;
					continue;
				}
			if (soap_flag_courseName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "courseName", &a->courseName, "xsd:string"))
				{	soap_flag_courseName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__loginBySessionKeyOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__loginBySessionKeyOutput, 0, sizeof(struct swad__loginBySessionKeyOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userCode > 0 || soap_flag_degreeTypeCode > 0 || soap_flag_degreeCode > 0 || soap_flag_courseCode > 0 || soap_flag_userRole > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__loginBySessionKeyOutput(struct soap *soap, const struct swad__loginBySessionKeyOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__loginBySessionKeyOutput);
	if (soap_out_swad__loginBySessionKeyOutput(soap, tag?tag:"swad:loginBySessionKeyOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__loginBySessionKeyOutput * SOAP_FMAC4 soap_get_swad__loginBySessionKeyOutput(struct soap *soap, struct swad__loginBySessionKeyOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__loginBySessionKeyOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_swad__createAccountOutput(struct soap *soap, struct swad__createAccountOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->userCode);
	soap_default_string(soap, &a->string);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_swad__createAccountOutput(struct soap *soap, const struct swad__createAccountOutput *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_swad__createAccountOutput(struct soap *soap, const char *tag, int id, const struct swad__createAccountOutput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_swad__createAccountOutput), type))
		return soap->error;
	if (soap_out_int(soap, "userCode", -1, &a->userCode, ""))
		return soap->error;
	if (soap_out_string(soap, "string", -1, &a->string, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct swad__createAccountOutput * SOAP_FMAC4 soap_in_swad__createAccountOutput(struct soap *soap, const char *tag, struct swad__createAccountOutput *a, const char *type)
{
	size_t soap_flag_userCode = 1;
	size_t soap_flag_string = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct swad__createAccountOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_swad__createAccountOutput, sizeof(struct swad__createAccountOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_swad__createAccountOutput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "userCode", &a->userCode, "xsd:int"))
				{	soap_flag_userCode--;
					continue;
				}
			if (soap_flag_string && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "string", &a->string, "xsd:string"))
				{	soap_flag_string--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct swad__createAccountOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_swad__createAccountOutput, 0, sizeof(struct swad__createAccountOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_swad__createAccountOutput(struct soap *soap, const struct swad__createAccountOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_swad__createAccountOutput);
	if (soap_out_swad__createAccountOutput(soap, tag?tag:"swad:createAccountOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__createAccountOutput * SOAP_FMAC4 soap_get_swad__createAccountOutput(struct soap *soap, struct swad__createAccountOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_swad__createAccountOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__sendMessageOutput(struct soap *soap, struct swad__sendMessageOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__sendMessageOutput))
		soap_serialize_swad__sendMessageOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__sendMessageOutput(struct soap *soap, const char *tag, int id, struct swad__sendMessageOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__sendMessageOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__sendMessageOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__sendMessageOutput ** SOAP_FMAC4 soap_in_PointerToswad__sendMessageOutput(struct soap *soap, const char *tag, struct swad__sendMessageOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__sendMessageOutput **)soap_malloc(soap, sizeof(struct swad__sendMessageOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__sendMessageOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__sendMessageOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__sendMessageOutput, sizeof(struct swad__sendMessageOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__sendMessageOutput(struct soap *soap, struct swad__sendMessageOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__sendMessageOutput);
	if (soap_out_PointerToswad__sendMessageOutput(soap, tag?tag:"swad:sendMessageOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__sendMessageOutput ** SOAP_FMAC4 soap_get_PointerToswad__sendMessageOutput(struct soap *soap, struct swad__sendMessageOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__sendMessageOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__sendNoticeOutput(struct soap *soap, struct swad__sendNoticeOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__sendNoticeOutput))
		soap_serialize_swad__sendNoticeOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__sendNoticeOutput(struct soap *soap, const char *tag, int id, struct swad__sendNoticeOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__sendNoticeOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__sendNoticeOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__sendNoticeOutput ** SOAP_FMAC4 soap_in_PointerToswad__sendNoticeOutput(struct soap *soap, const char *tag, struct swad__sendNoticeOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__sendNoticeOutput **)soap_malloc(soap, sizeof(struct swad__sendNoticeOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__sendNoticeOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__sendNoticeOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__sendNoticeOutput, sizeof(struct swad__sendNoticeOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__sendNoticeOutput(struct soap *soap, struct swad__sendNoticeOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__sendNoticeOutput);
	if (soap_out_PointerToswad__sendNoticeOutput(soap, tag?tag:"swad:sendNoticeOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__sendNoticeOutput ** SOAP_FMAC4 soap_get_PointerToswad__sendNoticeOutput(struct soap *soap, struct swad__sendNoticeOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__sendNoticeOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__markNotificationsAsReadOutput(struct soap *soap, struct swad__markNotificationsAsReadOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__markNotificationsAsReadOutput))
		soap_serialize_swad__markNotificationsAsReadOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__markNotificationsAsReadOutput(struct soap *soap, const char *tag, int id, struct swad__markNotificationsAsReadOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__markNotificationsAsReadOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__markNotificationsAsReadOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__markNotificationsAsReadOutput ** SOAP_FMAC4 soap_in_PointerToswad__markNotificationsAsReadOutput(struct soap *soap, const char *tag, struct swad__markNotificationsAsReadOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__markNotificationsAsReadOutput **)soap_malloc(soap, sizeof(struct swad__markNotificationsAsReadOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__markNotificationsAsReadOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__markNotificationsAsReadOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__markNotificationsAsReadOutput, sizeof(struct swad__markNotificationsAsReadOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__markNotificationsAsReadOutput(struct soap *soap, struct swad__markNotificationsAsReadOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__markNotificationsAsReadOutput);
	if (soap_out_PointerToswad__markNotificationsAsReadOutput(soap, tag?tag:"swad:markNotificationsAsReadOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__markNotificationsAsReadOutput ** SOAP_FMAC4 soap_get_PointerToswad__markNotificationsAsReadOutput(struct soap *soap, struct swad__markNotificationsAsReadOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__markNotificationsAsReadOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__getNotificationsOutput(struct soap *soap, struct swad__getNotificationsOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__getNotificationsOutput))
		soap_serialize_swad__getNotificationsOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__getNotificationsOutput(struct soap *soap, const char *tag, int id, struct swad__getNotificationsOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__getNotificationsOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__getNotificationsOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__getNotificationsOutput ** SOAP_FMAC4 soap_in_PointerToswad__getNotificationsOutput(struct soap *soap, const char *tag, struct swad__getNotificationsOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__getNotificationsOutput **)soap_malloc(soap, sizeof(struct swad__getNotificationsOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__getNotificationsOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__getNotificationsOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__getNotificationsOutput, sizeof(struct swad__getNotificationsOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__getNotificationsOutput(struct soap *soap, struct swad__getNotificationsOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__getNotificationsOutput);
	if (soap_out_PointerToswad__getNotificationsOutput(soap, tag?tag:"swad:getNotificationsOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getNotificationsOutput ** SOAP_FMAC4 soap_get_PointerToswad__getNotificationsOutput(struct soap *soap, struct swad__getNotificationsOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__getNotificationsOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__sendAttendanceUsersOutput(struct soap *soap, struct swad__sendAttendanceUsersOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__sendAttendanceUsersOutput))
		soap_serialize_swad__sendAttendanceUsersOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__sendAttendanceUsersOutput(struct soap *soap, const char *tag, int id, struct swad__sendAttendanceUsersOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__sendAttendanceUsersOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__sendAttendanceUsersOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__sendAttendanceUsersOutput ** SOAP_FMAC4 soap_in_PointerToswad__sendAttendanceUsersOutput(struct soap *soap, const char *tag, struct swad__sendAttendanceUsersOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__sendAttendanceUsersOutput **)soap_malloc(soap, sizeof(struct swad__sendAttendanceUsersOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__sendAttendanceUsersOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__sendAttendanceUsersOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__sendAttendanceUsersOutput, sizeof(struct swad__sendAttendanceUsersOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__sendAttendanceUsersOutput(struct soap *soap, struct swad__sendAttendanceUsersOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__sendAttendanceUsersOutput);
	if (soap_out_PointerToswad__sendAttendanceUsersOutput(soap, tag?tag:"swad:sendAttendanceUsersOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__sendAttendanceUsersOutput ** SOAP_FMAC4 soap_get_PointerToswad__sendAttendanceUsersOutput(struct soap *soap, struct swad__sendAttendanceUsersOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__sendAttendanceUsersOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__getAttendanceUsersOutput(struct soap *soap, struct swad__getAttendanceUsersOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__getAttendanceUsersOutput))
		soap_serialize_swad__getAttendanceUsersOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__getAttendanceUsersOutput(struct soap *soap, const char *tag, int id, struct swad__getAttendanceUsersOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__getAttendanceUsersOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__getAttendanceUsersOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__getAttendanceUsersOutput ** SOAP_FMAC4 soap_in_PointerToswad__getAttendanceUsersOutput(struct soap *soap, const char *tag, struct swad__getAttendanceUsersOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__getAttendanceUsersOutput **)soap_malloc(soap, sizeof(struct swad__getAttendanceUsersOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__getAttendanceUsersOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__getAttendanceUsersOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__getAttendanceUsersOutput, sizeof(struct swad__getAttendanceUsersOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__getAttendanceUsersOutput(struct soap *soap, struct swad__getAttendanceUsersOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__getAttendanceUsersOutput);
	if (soap_out_PointerToswad__getAttendanceUsersOutput(soap, tag?tag:"swad:getAttendanceUsersOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getAttendanceUsersOutput ** SOAP_FMAC4 soap_get_PointerToswad__getAttendanceUsersOutput(struct soap *soap, struct swad__getAttendanceUsersOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__getAttendanceUsersOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__sendAttendanceEventOutput(struct soap *soap, struct swad__sendAttendanceEventOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__sendAttendanceEventOutput))
		soap_serialize_swad__sendAttendanceEventOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__sendAttendanceEventOutput(struct soap *soap, const char *tag, int id, struct swad__sendAttendanceEventOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__sendAttendanceEventOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__sendAttendanceEventOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__sendAttendanceEventOutput ** SOAP_FMAC4 soap_in_PointerToswad__sendAttendanceEventOutput(struct soap *soap, const char *tag, struct swad__sendAttendanceEventOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__sendAttendanceEventOutput **)soap_malloc(soap, sizeof(struct swad__sendAttendanceEventOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__sendAttendanceEventOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__sendAttendanceEventOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__sendAttendanceEventOutput, sizeof(struct swad__sendAttendanceEventOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__sendAttendanceEventOutput(struct soap *soap, struct swad__sendAttendanceEventOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__sendAttendanceEventOutput);
	if (soap_out_PointerToswad__sendAttendanceEventOutput(soap, tag?tag:"swad:sendAttendanceEventOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__sendAttendanceEventOutput ** SOAP_FMAC4 soap_get_PointerToswad__sendAttendanceEventOutput(struct soap *soap, struct swad__sendAttendanceEventOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__sendAttendanceEventOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__getAttendanceEventsOutput(struct soap *soap, struct swad__getAttendanceEventsOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__getAttendanceEventsOutput))
		soap_serialize_swad__getAttendanceEventsOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__getAttendanceEventsOutput(struct soap *soap, const char *tag, int id, struct swad__getAttendanceEventsOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__getAttendanceEventsOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__getAttendanceEventsOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__getAttendanceEventsOutput ** SOAP_FMAC4 soap_in_PointerToswad__getAttendanceEventsOutput(struct soap *soap, const char *tag, struct swad__getAttendanceEventsOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__getAttendanceEventsOutput **)soap_malloc(soap, sizeof(struct swad__getAttendanceEventsOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__getAttendanceEventsOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__getAttendanceEventsOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__getAttendanceEventsOutput, sizeof(struct swad__getAttendanceEventsOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__getAttendanceEventsOutput(struct soap *soap, struct swad__getAttendanceEventsOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__getAttendanceEventsOutput);
	if (soap_out_PointerToswad__getAttendanceEventsOutput(soap, tag?tag:"swad:getAttendanceEventsOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getAttendanceEventsOutput ** SOAP_FMAC4 soap_get_PointerToswad__getAttendanceEventsOutput(struct soap *soap, struct swad__getAttendanceEventsOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__getAttendanceEventsOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__getUsersOutput(struct soap *soap, struct swad__getUsersOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__getUsersOutput))
		soap_serialize_swad__getUsersOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__getUsersOutput(struct soap *soap, const char *tag, int id, struct swad__getUsersOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__getUsersOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__getUsersOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__getUsersOutput ** SOAP_FMAC4 soap_in_PointerToswad__getUsersOutput(struct soap *soap, const char *tag, struct swad__getUsersOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__getUsersOutput **)soap_malloc(soap, sizeof(struct swad__getUsersOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__getUsersOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__getUsersOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__getUsersOutput, sizeof(struct swad__getUsersOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__getUsersOutput(struct soap *soap, struct swad__getUsersOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__getUsersOutput);
	if (soap_out_PointerToswad__getUsersOutput(soap, tag?tag:"swad:getUsersOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getUsersOutput ** SOAP_FMAC4 soap_get_PointerToswad__getUsersOutput(struct soap *soap, struct swad__getUsersOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__getUsersOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__getTestsOutput(struct soap *soap, struct swad__getTestsOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__getTestsOutput))
		soap_serialize_swad__getTestsOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__getTestsOutput(struct soap *soap, const char *tag, int id, struct swad__getTestsOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__getTestsOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__getTestsOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__getTestsOutput ** SOAP_FMAC4 soap_in_PointerToswad__getTestsOutput(struct soap *soap, const char *tag, struct swad__getTestsOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__getTestsOutput **)soap_malloc(soap, sizeof(struct swad__getTestsOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__getTestsOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__getTestsOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__getTestsOutput, sizeof(struct swad__getTestsOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__getTestsOutput(struct soap *soap, struct swad__getTestsOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__getTestsOutput);
	if (soap_out_PointerToswad__getTestsOutput(soap, tag?tag:"swad:getTestsOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getTestsOutput ** SOAP_FMAC4 soap_get_PointerToswad__getTestsOutput(struct soap *soap, struct swad__getTestsOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__getTestsOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__getTestConfigOutput(struct soap *soap, struct swad__getTestConfigOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__getTestConfigOutput))
		soap_serialize_swad__getTestConfigOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__getTestConfigOutput(struct soap *soap, const char *tag, int id, struct swad__getTestConfigOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__getTestConfigOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__getTestConfigOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__getTestConfigOutput ** SOAP_FMAC4 soap_in_PointerToswad__getTestConfigOutput(struct soap *soap, const char *tag, struct swad__getTestConfigOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__getTestConfigOutput **)soap_malloc(soap, sizeof(struct swad__getTestConfigOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__getTestConfigOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__getTestConfigOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__getTestConfigOutput, sizeof(struct swad__getTestConfigOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__getTestConfigOutput(struct soap *soap, struct swad__getTestConfigOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__getTestConfigOutput);
	if (soap_out_PointerToswad__getTestConfigOutput(soap, tag?tag:"swad:getTestConfigOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getTestConfigOutput ** SOAP_FMAC4 soap_get_PointerToswad__getTestConfigOutput(struct soap *soap, struct swad__getTestConfigOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__getTestConfigOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__getMarksOutput(struct soap *soap, struct swad__getMarksOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__getMarksOutput))
		soap_serialize_swad__getMarksOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__getMarksOutput(struct soap *soap, const char *tag, int id, struct swad__getMarksOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__getMarksOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__getMarksOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__getMarksOutput ** SOAP_FMAC4 soap_in_PointerToswad__getMarksOutput(struct soap *soap, const char *tag, struct swad__getMarksOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__getMarksOutput **)soap_malloc(soap, sizeof(struct swad__getMarksOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__getMarksOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__getMarksOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__getMarksOutput, sizeof(struct swad__getMarksOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__getMarksOutput(struct soap *soap, struct swad__getMarksOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__getMarksOutput);
	if (soap_out_PointerToswad__getMarksOutput(soap, tag?tag:"swad:getMarksOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getMarksOutput ** SOAP_FMAC4 soap_get_PointerToswad__getMarksOutput(struct soap *soap, struct swad__getMarksOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__getMarksOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__getFileOutput(struct soap *soap, struct swad__getFileOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__getFileOutput))
		soap_serialize_swad__getFileOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__getFileOutput(struct soap *soap, const char *tag, int id, struct swad__getFileOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__getFileOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__getFileOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__getFileOutput ** SOAP_FMAC4 soap_in_PointerToswad__getFileOutput(struct soap *soap, const char *tag, struct swad__getFileOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__getFileOutput **)soap_malloc(soap, sizeof(struct swad__getFileOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__getFileOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__getFileOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__getFileOutput, sizeof(struct swad__getFileOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__getFileOutput(struct soap *soap, struct swad__getFileOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__getFileOutput);
	if (soap_out_PointerToswad__getFileOutput(soap, tag?tag:"swad:getFileOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getFileOutput ** SOAP_FMAC4 soap_get_PointerToswad__getFileOutput(struct soap *soap, struct swad__getFileOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__getFileOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__getDirectoryTreeOutput(struct soap *soap, struct swad__getDirectoryTreeOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__getDirectoryTreeOutput))
		soap_serialize_swad__getDirectoryTreeOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__getDirectoryTreeOutput(struct soap *soap, const char *tag, int id, struct swad__getDirectoryTreeOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__getDirectoryTreeOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__getDirectoryTreeOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__getDirectoryTreeOutput ** SOAP_FMAC4 soap_in_PointerToswad__getDirectoryTreeOutput(struct soap *soap, const char *tag, struct swad__getDirectoryTreeOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__getDirectoryTreeOutput **)soap_malloc(soap, sizeof(struct swad__getDirectoryTreeOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__getDirectoryTreeOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__getDirectoryTreeOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__getDirectoryTreeOutput, sizeof(struct swad__getDirectoryTreeOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__getDirectoryTreeOutput(struct soap *soap, struct swad__getDirectoryTreeOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__getDirectoryTreeOutput);
	if (soap_out_PointerToswad__getDirectoryTreeOutput(soap, tag?tag:"swad:getDirectoryTreeOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getDirectoryTreeOutput ** SOAP_FMAC4 soap_get_PointerToswad__getDirectoryTreeOutput(struct soap *soap, struct swad__getDirectoryTreeOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__getDirectoryTreeOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__sendMyGroupsOutput(struct soap *soap, struct swad__sendMyGroupsOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__sendMyGroupsOutput))
		soap_serialize_swad__sendMyGroupsOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__sendMyGroupsOutput(struct soap *soap, const char *tag, int id, struct swad__sendMyGroupsOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__sendMyGroupsOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__sendMyGroupsOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__sendMyGroupsOutput ** SOAP_FMAC4 soap_in_PointerToswad__sendMyGroupsOutput(struct soap *soap, const char *tag, struct swad__sendMyGroupsOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__sendMyGroupsOutput **)soap_malloc(soap, sizeof(struct swad__sendMyGroupsOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__sendMyGroupsOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__sendMyGroupsOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__sendMyGroupsOutput, sizeof(struct swad__sendMyGroupsOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__sendMyGroupsOutput(struct soap *soap, struct swad__sendMyGroupsOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__sendMyGroupsOutput);
	if (soap_out_PointerToswad__sendMyGroupsOutput(soap, tag?tag:"swad:sendMyGroupsOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__sendMyGroupsOutput ** SOAP_FMAC4 soap_get_PointerToswad__sendMyGroupsOutput(struct soap *soap, struct swad__sendMyGroupsOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__sendMyGroupsOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__getGroupsOutput(struct soap *soap, struct swad__getGroupsOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__getGroupsOutput))
		soap_serialize_swad__getGroupsOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__getGroupsOutput(struct soap *soap, const char *tag, int id, struct swad__getGroupsOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__getGroupsOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__getGroupsOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__getGroupsOutput ** SOAP_FMAC4 soap_in_PointerToswad__getGroupsOutput(struct soap *soap, const char *tag, struct swad__getGroupsOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__getGroupsOutput **)soap_malloc(soap, sizeof(struct swad__getGroupsOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__getGroupsOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__getGroupsOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__getGroupsOutput, sizeof(struct swad__getGroupsOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__getGroupsOutput(struct soap *soap, struct swad__getGroupsOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__getGroupsOutput);
	if (soap_out_PointerToswad__getGroupsOutput(soap, tag?tag:"swad:getGroupsOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getGroupsOutput ** SOAP_FMAC4 soap_get_PointerToswad__getGroupsOutput(struct soap *soap, struct swad__getGroupsOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__getGroupsOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__getGroupTypesOutput(struct soap *soap, struct swad__getGroupTypesOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__getGroupTypesOutput))
		soap_serialize_swad__getGroupTypesOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__getGroupTypesOutput(struct soap *soap, const char *tag, int id, struct swad__getGroupTypesOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__getGroupTypesOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__getGroupTypesOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__getGroupTypesOutput ** SOAP_FMAC4 soap_in_PointerToswad__getGroupTypesOutput(struct soap *soap, const char *tag, struct swad__getGroupTypesOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__getGroupTypesOutput **)soap_malloc(soap, sizeof(struct swad__getGroupTypesOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__getGroupTypesOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__getGroupTypesOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__getGroupTypesOutput, sizeof(struct swad__getGroupTypesOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__getGroupTypesOutput(struct soap *soap, struct swad__getGroupTypesOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__getGroupTypesOutput);
	if (soap_out_PointerToswad__getGroupTypesOutput(soap, tag?tag:"swad:getGroupTypesOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getGroupTypesOutput ** SOAP_FMAC4 soap_get_PointerToswad__getGroupTypesOutput(struct soap *soap, struct swad__getGroupTypesOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__getGroupTypesOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__getCourseInfoOutput(struct soap *soap, struct swad__getCourseInfoOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__getCourseInfoOutput))
		soap_serialize_swad__getCourseInfoOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__getCourseInfoOutput(struct soap *soap, const char *tag, int id, struct swad__getCourseInfoOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__getCourseInfoOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__getCourseInfoOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__getCourseInfoOutput ** SOAP_FMAC4 soap_in_PointerToswad__getCourseInfoOutput(struct soap *soap, const char *tag, struct swad__getCourseInfoOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__getCourseInfoOutput **)soap_malloc(soap, sizeof(struct swad__getCourseInfoOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__getCourseInfoOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__getCourseInfoOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__getCourseInfoOutput, sizeof(struct swad__getCourseInfoOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__getCourseInfoOutput(struct soap *soap, struct swad__getCourseInfoOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__getCourseInfoOutput);
	if (soap_out_PointerToswad__getCourseInfoOutput(soap, tag?tag:"swad:getCourseInfoOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getCourseInfoOutput ** SOAP_FMAC4 soap_get_PointerToswad__getCourseInfoOutput(struct soap *soap, struct swad__getCourseInfoOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__getCourseInfoOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__getCoursesOutput(struct soap *soap, struct swad__getCoursesOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__getCoursesOutput))
		soap_serialize_swad__getCoursesOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__getCoursesOutput(struct soap *soap, const char *tag, int id, struct swad__getCoursesOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__getCoursesOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__getCoursesOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__getCoursesOutput ** SOAP_FMAC4 soap_in_PointerToswad__getCoursesOutput(struct soap *soap, const char *tag, struct swad__getCoursesOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__getCoursesOutput **)soap_malloc(soap, sizeof(struct swad__getCoursesOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__getCoursesOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__getCoursesOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__getCoursesOutput, sizeof(struct swad__getCoursesOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__getCoursesOutput(struct soap *soap, struct swad__getCoursesOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__getCoursesOutput);
	if (soap_out_PointerToswad__getCoursesOutput(soap, tag?tag:"swad:getCoursesOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getCoursesOutput ** SOAP_FMAC4 soap_get_PointerToswad__getCoursesOutput(struct soap *soap, struct swad__getCoursesOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__getCoursesOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__getNewPasswordOutput(struct soap *soap, struct swad__getNewPasswordOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__getNewPasswordOutput))
		soap_serialize_swad__getNewPasswordOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__getNewPasswordOutput(struct soap *soap, const char *tag, int id, struct swad__getNewPasswordOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__getNewPasswordOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__getNewPasswordOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__getNewPasswordOutput ** SOAP_FMAC4 soap_in_PointerToswad__getNewPasswordOutput(struct soap *soap, const char *tag, struct swad__getNewPasswordOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__getNewPasswordOutput **)soap_malloc(soap, sizeof(struct swad__getNewPasswordOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__getNewPasswordOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__getNewPasswordOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__getNewPasswordOutput, sizeof(struct swad__getNewPasswordOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__getNewPasswordOutput(struct soap *soap, struct swad__getNewPasswordOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__getNewPasswordOutput);
	if (soap_out_PointerToswad__getNewPasswordOutput(soap, tag?tag:"swad:getNewPasswordOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__getNewPasswordOutput ** SOAP_FMAC4 soap_get_PointerToswad__getNewPasswordOutput(struct soap *soap, struct swad__getNewPasswordOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__getNewPasswordOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__loginBySessionKeyOutput(struct soap *soap, struct swad__loginBySessionKeyOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__loginBySessionKeyOutput))
		soap_serialize_swad__loginBySessionKeyOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__loginBySessionKeyOutput(struct soap *soap, const char *tag, int id, struct swad__loginBySessionKeyOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__loginBySessionKeyOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__loginBySessionKeyOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__loginBySessionKeyOutput ** SOAP_FMAC4 soap_in_PointerToswad__loginBySessionKeyOutput(struct soap *soap, const char *tag, struct swad__loginBySessionKeyOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__loginBySessionKeyOutput **)soap_malloc(soap, sizeof(struct swad__loginBySessionKeyOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__loginBySessionKeyOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__loginBySessionKeyOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__loginBySessionKeyOutput, sizeof(struct swad__loginBySessionKeyOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__loginBySessionKeyOutput(struct soap *soap, struct swad__loginBySessionKeyOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__loginBySessionKeyOutput);
	if (soap_out_PointerToswad__loginBySessionKeyOutput(soap, tag?tag:"swad:loginBySessionKeyOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__loginBySessionKeyOutput ** SOAP_FMAC4 soap_get_PointerToswad__loginBySessionKeyOutput(struct soap *soap, struct swad__loginBySessionKeyOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__loginBySessionKeyOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__loginByUserPasswordKeyOutput(struct soap *soap, struct swad__loginByUserPasswordKeyOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__loginByUserPasswordKeyOutput))
		soap_serialize_swad__loginByUserPasswordKeyOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__loginByUserPasswordKeyOutput(struct soap *soap, const char *tag, int id, struct swad__loginByUserPasswordKeyOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__loginByUserPasswordKeyOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__loginByUserPasswordKeyOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__loginByUserPasswordKeyOutput ** SOAP_FMAC4 soap_in_PointerToswad__loginByUserPasswordKeyOutput(struct soap *soap, const char *tag, struct swad__loginByUserPasswordKeyOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__loginByUserPasswordKeyOutput **)soap_malloc(soap, sizeof(struct swad__loginByUserPasswordKeyOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__loginByUserPasswordKeyOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__loginByUserPasswordKeyOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__loginByUserPasswordKeyOutput, sizeof(struct swad__loginByUserPasswordKeyOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__loginByUserPasswordKeyOutput(struct soap *soap, struct swad__loginByUserPasswordKeyOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__loginByUserPasswordKeyOutput);
	if (soap_out_PointerToswad__loginByUserPasswordKeyOutput(soap, tag?tag:"swad:loginByUserPasswordKeyOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__loginByUserPasswordKeyOutput ** SOAP_FMAC4 soap_get_PointerToswad__loginByUserPasswordKeyOutput(struct soap *soap, struct swad__loginByUserPasswordKeyOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__loginByUserPasswordKeyOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__createAccountOutput(struct soap *soap, struct swad__createAccountOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__createAccountOutput))
		soap_serialize_swad__createAccountOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__createAccountOutput(struct soap *soap, const char *tag, int id, struct swad__createAccountOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__createAccountOutput);
	if (id < 0)
		return soap->error;
	return soap_out_swad__createAccountOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__createAccountOutput ** SOAP_FMAC4 soap_in_PointerToswad__createAccountOutput(struct soap *soap, const char *tag, struct swad__createAccountOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__createAccountOutput **)soap_malloc(soap, sizeof(struct swad__createAccountOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__createAccountOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__createAccountOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__createAccountOutput, sizeof(struct swad__createAccountOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__createAccountOutput(struct soap *soap, struct swad__createAccountOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__createAccountOutput);
	if (soap_out_PointerToswad__createAccountOutput(soap, tag?tag:"swad:createAccountOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__createAccountOutput ** SOAP_FMAC4 soap_get_PointerToswad__createAccountOutput(struct soap *soap, struct swad__createAccountOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__createAccountOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__attendanceUser(struct soap *soap, struct swad__attendanceUser *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__attendanceUser))
		soap_serialize_swad__attendanceUser(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__attendanceUser(struct soap *soap, const char *tag, int id, struct swad__attendanceUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__attendanceUser);
	if (id < 0)
		return soap->error;
	return soap_out_swad__attendanceUser(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__attendanceUser ** SOAP_FMAC4 soap_in_PointerToswad__attendanceUser(struct soap *soap, const char *tag, struct swad__attendanceUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__attendanceUser **)soap_malloc(soap, sizeof(struct swad__attendanceUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__attendanceUser(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__attendanceUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__attendanceUser, sizeof(struct swad__attendanceUser), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__attendanceUser(struct soap *soap, struct swad__attendanceUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__attendanceUser);
	if (soap_out_PointerToswad__attendanceUser(soap, tag?tag:"swad:attendanceUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__attendanceUser ** SOAP_FMAC4 soap_get_PointerToswad__attendanceUser(struct soap *soap, struct swad__attendanceUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__attendanceUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__attendanceEvent(struct soap *soap, struct swad__attendanceEvent *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__attendanceEvent))
		soap_serialize_swad__attendanceEvent(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__attendanceEvent(struct soap *soap, const char *tag, int id, struct swad__attendanceEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__attendanceEvent);
	if (id < 0)
		return soap->error;
	return soap_out_swad__attendanceEvent(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__attendanceEvent ** SOAP_FMAC4 soap_in_PointerToswad__attendanceEvent(struct soap *soap, const char *tag, struct swad__attendanceEvent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__attendanceEvent **)soap_malloc(soap, sizeof(struct swad__attendanceEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__attendanceEvent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__attendanceEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__attendanceEvent, sizeof(struct swad__attendanceEvent), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__attendanceEvent(struct soap *soap, struct swad__attendanceEvent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__attendanceEvent);
	if (soap_out_PointerToswad__attendanceEvent(soap, tag?tag:"swad:attendanceEvent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__attendanceEvent ** SOAP_FMAC4 soap_get_PointerToswad__attendanceEvent(struct soap *soap, struct swad__attendanceEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__attendanceEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__user(struct soap *soap, struct swad__user *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__user))
		soap_serialize_swad__user(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__user(struct soap *soap, const char *tag, int id, struct swad__user *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__user);
	if (id < 0)
		return soap->error;
	return soap_out_swad__user(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__user ** SOAP_FMAC4 soap_in_PointerToswad__user(struct soap *soap, const char *tag, struct swad__user **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__user **)soap_malloc(soap, sizeof(struct swad__user *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__user(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__user **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__user, sizeof(struct swad__user), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__user(struct soap *soap, struct swad__user *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__user);
	if (soap_out_PointerToswad__user(soap, tag?tag:"swad:user", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__user ** SOAP_FMAC4 soap_get_PointerToswad__user(struct soap *soap, struct swad__user **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__user(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__questionTag(struct soap *soap, struct swad__questionTag *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__questionTag))
		soap_serialize_swad__questionTag(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__questionTag(struct soap *soap, const char *tag, int id, struct swad__questionTag *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__questionTag);
	if (id < 0)
		return soap->error;
	return soap_out_swad__questionTag(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__questionTag ** SOAP_FMAC4 soap_in_PointerToswad__questionTag(struct soap *soap, const char *tag, struct swad__questionTag **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__questionTag **)soap_malloc(soap, sizeof(struct swad__questionTag *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__questionTag(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__questionTag **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__questionTag, sizeof(struct swad__questionTag), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__questionTag(struct soap *soap, struct swad__questionTag *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__questionTag);
	if (soap_out_PointerToswad__questionTag(soap, tag?tag:"swad:questionTag", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__questionTag ** SOAP_FMAC4 soap_get_PointerToswad__questionTag(struct soap *soap, struct swad__questionTag **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__questionTag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__answer(struct soap *soap, struct swad__answer *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__answer))
		soap_serialize_swad__answer(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__answer(struct soap *soap, const char *tag, int id, struct swad__answer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__answer);
	if (id < 0)
		return soap->error;
	return soap_out_swad__answer(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__answer ** SOAP_FMAC4 soap_in_PointerToswad__answer(struct soap *soap, const char *tag, struct swad__answer **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__answer **)soap_malloc(soap, sizeof(struct swad__answer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__answer(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__answer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__answer, sizeof(struct swad__answer), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__answer(struct soap *soap, struct swad__answer *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__answer);
	if (soap_out_PointerToswad__answer(soap, tag?tag:"swad:answer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__answer ** SOAP_FMAC4 soap_get_PointerToswad__answer(struct soap *soap, struct swad__answer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__answer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__question(struct soap *soap, struct swad__question *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__question))
		soap_serialize_swad__question(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__question(struct soap *soap, const char *tag, int id, struct swad__question *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__question);
	if (id < 0)
		return soap->error;
	return soap_out_swad__question(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__question ** SOAP_FMAC4 soap_in_PointerToswad__question(struct soap *soap, const char *tag, struct swad__question **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__question **)soap_malloc(soap, sizeof(struct swad__question *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__question(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__question **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__question, sizeof(struct swad__question), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__question(struct soap *soap, struct swad__question *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__question);
	if (soap_out_PointerToswad__question(soap, tag?tag:"swad:question", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__question ** SOAP_FMAC4 soap_get_PointerToswad__question(struct soap *soap, struct swad__question **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__question(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__tag(struct soap *soap, struct swad__tag *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__tag))
		soap_serialize_swad__tag(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__tag(struct soap *soap, const char *tag, int id, struct swad__tag *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__tag);
	if (id < 0)
		return soap->error;
	return soap_out_swad__tag(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__tag ** SOAP_FMAC4 soap_in_PointerToswad__tag(struct soap *soap, const char *tag, struct swad__tag **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__tag **)soap_malloc(soap, sizeof(struct swad__tag *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__tag(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__tag **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__tag, sizeof(struct swad__tag), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__tag(struct soap *soap, struct swad__tag *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__tag);
	if (soap_out_PointerToswad__tag(soap, tag?tag:"swad:tag", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__tag ** SOAP_FMAC4 soap_get_PointerToswad__tag(struct soap *soap, struct swad__tag **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__tag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__notification(struct soap *soap, struct swad__notification *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__notification))
		soap_serialize_swad__notification(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__notification(struct soap *soap, const char *tag, int id, struct swad__notification *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__notification);
	if (id < 0)
		return soap->error;
	return soap_out_swad__notification(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__notification ** SOAP_FMAC4 soap_in_PointerToswad__notification(struct soap *soap, const char *tag, struct swad__notification **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__notification **)soap_malloc(soap, sizeof(struct swad__notification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__notification(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__notification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__notification, sizeof(struct swad__notification), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__notification(struct soap *soap, struct swad__notification *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__notification);
	if (soap_out_PointerToswad__notification(soap, tag?tag:"swad:notification", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__notification ** SOAP_FMAC4 soap_get_PointerToswad__notification(struct soap *soap, struct swad__notification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__notification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__group(struct soap *soap, struct swad__group *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__group))
		soap_serialize_swad__group(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__group(struct soap *soap, const char *tag, int id, struct swad__group *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__group);
	if (id < 0)
		return soap->error;
	return soap_out_swad__group(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__group ** SOAP_FMAC4 soap_in_PointerToswad__group(struct soap *soap, const char *tag, struct swad__group **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__group **)soap_malloc(soap, sizeof(struct swad__group *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__group(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__group **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__group, sizeof(struct swad__group), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__group(struct soap *soap, struct swad__group *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__group);
	if (soap_out_PointerToswad__group(soap, tag?tag:"swad:group", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__group ** SOAP_FMAC4 soap_get_PointerToswad__group(struct soap *soap, struct swad__group **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__group(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__groupType(struct soap *soap, struct swad__groupType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__groupType))
		soap_serialize_swad__groupType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__groupType(struct soap *soap, const char *tag, int id, struct swad__groupType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__groupType);
	if (id < 0)
		return soap->error;
	return soap_out_swad__groupType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__groupType ** SOAP_FMAC4 soap_in_PointerToswad__groupType(struct soap *soap, const char *tag, struct swad__groupType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__groupType **)soap_malloc(soap, sizeof(struct swad__groupType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__groupType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__groupType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__groupType, sizeof(struct swad__groupType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__groupType(struct soap *soap, struct swad__groupType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__groupType);
	if (soap_out_PointerToswad__groupType(soap, tag?tag:"swad:groupType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__groupType ** SOAP_FMAC4 soap_get_PointerToswad__groupType(struct soap *soap, struct swad__groupType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__groupType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToswad__course(struct soap *soap, struct swad__course *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_swad__course))
		soap_serialize_swad__course(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToswad__course(struct soap *soap, const char *tag, int id, struct swad__course *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_swad__course);
	if (id < 0)
		return soap->error;
	return soap_out_swad__course(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct swad__course ** SOAP_FMAC4 soap_in_PointerToswad__course(struct soap *soap, const char *tag, struct swad__course **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct swad__course **)soap_malloc(soap, sizeof(struct swad__course *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_swad__course(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct swad__course **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_swad__course, sizeof(struct swad__course), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToswad__course(struct soap *soap, struct swad__course *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToswad__course);
	if (soap_out_PointerToswad__course(soap, tag?tag:"swad:course", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct swad__course ** SOAP_FMAC4 soap_get_PointerToswad__course(struct soap *soap, struct swad__course **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToswad__course(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
